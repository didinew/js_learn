1️⃣ 为什么频繁操作 DOM 会卡顿？
	•	DOM 操作是昂贵的
	•	浏览器渲染流程：JS 执行 → 样式计算 → 布局（reflow） → 绘制（repaint） → 合成（composite）
	•	每次修改 DOM 可能触发 reflow/repaint，尤其是影响布局的属性（如 width/height/top/left/margin）。
	•	频繁修改 DOM 会触发多次重排
	•	例子：

for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  document.body.appendChild(div); // 每次 append 都可能触发重排
}

→ 100 次操作就可能触发 100 次布局计算，非常耗性能。

	•	优化方式
	•	批量操作 DOM（DocumentFragment、一次性 innerHTML）
	•	避免触发同步布局（不要频繁读写 offsetHeight 等属性）
	•	使用虚拟 DOM 或框架做批量渲染

✅ 核心理解：DOM 操作会直接影响渲染树、布局和绘制，频繁操作意味着浏览器要不停地计算布局和重绘，导致卡顿。

⸻

2️⃣ 为什么 transform/opacity 动画比 top/left 更流畅？
	•	top/left 改变布局
	•	改变 top/left 会触发 布局计算（reflow） → 重绘（repaint） → 合成
	•	每帧都要重新计算位置，重排元素周围的布局，很耗性能。
	•	transform/opacity 可以 GPU 加速
	•	改变 transform（如 translate, scale, rotate）和 opacity 不触发布局计算，只影响 合成层（composite layer）
	•	GPU 直接处理图层合成，避免 CPU 布局计算 → 更流畅
	•	总结

属性
触发
渲染影响
top/left
reflow + repaint
整个布局重新计算
transform
composite
只影响图层合成
opacity
composite
只影响图层合成


✅ 核心理解：能只操作 GPU 层的动画比操作布局属性的动画更流畅。

3️⃣ React/Vue 为什么引入虚拟 DOM？
	•	虚拟 DOM 的本质
	•	将真实 DOM 用 JS 对象 描述 → 在 JS 内部操作 → 最终计算差异再批量更新真实 DOM。
	•	问题解决
	1.	减少直接 DOM 操作开销
	•	直接操作 DOM 每次都可能触发重排/重绘，虚拟 DOM 可以先在内存里批量计算变化。
	2.	提供跨平台能力
	•	React Native、Vue 可以用相同的渲染逻辑渲染到不同平台。
	3.	便于状态管理和组件化
	•	状态变化 → 重新渲染虚拟 DOM → diff → 最小化 DOM 更新。
	•	示意
state 改变 → render 出新虚拟 DOM → diff 与旧虚拟 DOM → 生成最小 DOM 更新 → 应用到真实 DOM


✅ 核心理解：虚拟 DOM 是为了性能优化 + 可维护性 + 跨平台，避免频繁操作昂贵的真实 DOM。

