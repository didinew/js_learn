事故 ①：接口返回顺序错乱（最常见，90% 团队踩过）

事故现场（React / Vue 通用）
```js
useEffect(() => {
  fetchDetail(id).then(setDetail)

}, [id])
```
线上现象
- 用户快速切换 id
- 页面偶尔显示旧数据
- 复现概率极低，测试测不出
---
根因（面试官最想听）

异步请求无序返回，后返回的旧请求覆盖了新状态
---
标准修复（生产级）

方案一：标记法（最通用）
```js
useEffect(() => {
  let expired = false

  fetchDetail(id).then(res => {
    if (!expired) setDetail(res)

  })

  return () => {

    expired = true
  }
}, [id])
```
---
方案二：AbortController（加分）
```js
useEffect(() => {
  const controller = new AbortController()

  fetch(url, { signal: controller.signal })

    .then(res => res.json())
    .then(setData)

  return () => controller.abort()

}, [id])
```
---
事故 ②：组件卸载后 setState（内存泄漏）

事故代码
```js
useEffect(() => {

  async function load() {

    const res = await fetchData()

    setData(res)
  }
  load()
}, [])
```
线上现象
- 控制台 warning
- 页面偶发卡顿
- 长列表滚动后性能下降
---
根因

```js
await 后组件已经 unmount，仍然 setState
```
---
修复（标准）

```js
useEffect(() => {
  let mounted = true

  fetchData().then(res => {
    if (mounted) setData(res)
  })

  return () => mounted = false

}, [])
```
---
事故 ③：并行请求写成串行（性能事故）

事故代码

```js
onMounted(async () => {
  const a = await fetchA()
  const b = await fetchB()
  const c = await fetchC()
```
})

线上现象
- 首屏慢 2~3 倍
- Lighthouse 评分异常
---
根因

多个 await 默认串行
---
修复（必会）
```js
onMounted(async () => {
  const [a, b, c] = await Promise.all([
    fetchA(),
    fetchB(),
    fetchC()

  ])
})
```
---
事故 ④：watchEffect + async 导致依赖丢失（Vue 专属坑）

事故代码
```js
watchEffect(async () => {
  await fetchData(state.id)

})
```
线上现象
- id 改了
- effect 不再重新执行
- 行为像“偶发失效”
---
根因（源码级）

依赖收集发生在 await 之前，await 后访问的响应式不再追踪
---
## 正确写法

```js
watch(

  () => state.id,
  async (id) => {

    await fetchData(id)

  }
)
```
---
事故 ⑤：async setup 阻塞首屏（Vue SSR / 移动端）

事故代码

```js
export default {

  async setup() {

    const data = await fetchData()
    return { data }

  }
}
```
线上现象
- 首屏白屏
- SSR TTFB 激增
---
根因

async setup 会被 Suspense 接管，组件渲染延迟
---
修复建议

setup() {
```js
  const data = ref(null)

  onMounted(async () => {

    data.value = await fetchData()
  })


  return { data }

}
```
---
事故 ⑥：forEach + async 导致业务“看似正常，实则全乱”

事故代码
```js
list.forEach(async item => {

  await submit(item)

})
```
线上现象
- 提交顺序错乱
- loading 提前结束
- 错误无法 catch
---
根因

forEach 不等待 Promise
---
标准写法
```js
await Promise.all(list.map(submit))

```
或：
```js
for (const item of list) {

  await submit(item)

}
```
---
面试官终极总结（直接背）

async/await 最大风险不是语法，而是异步竞态、生命周期错位、串行性能损耗。线上问题本质都来自“await 后代码仍然是异步”。
---