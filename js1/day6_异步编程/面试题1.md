① await 一定会产生微任务吗？

结论（必背）

是的，只要执行到 await，后续代码一定进入微任务队列

不管你 await 的是：
await Promise.resolve()
await 1
await null
await fetch()

原因

await x ≈

Promise.resolve(x).then(继续执行)
面试陷阱题

async function f() {
  console.log(1)
  await 2
  console.log(3)
}

f()
console.log(4)
输出：

1
4
3
❌ 很多人以为是 1 3 4

⸻

② 多个 await 是并行还是串行？

默认：串行（非常关键）

async function test() {
  const a = await fetchA()
  const b = await fetchB()
}

执行顺序：

fetchA → 等待 → fetchB

👉 总耗时 = A + B



⸻

并行写法（高级必会）

async function test() {
  const p1 = fetchA()
  const p2 = fetchB()

  const a = await p1
  const b = await p2
}

或更直接：

const [a, b] = await Promise.all([fetchA(), fetchB()])

👉 总耗时 = max(A, B)

面试官追问

为什么第一种是串行？

标准答案：

因为 await 会暂停当前 async 函数，只有前一个 Promise resolve 后，后面的代码才会执行。

⸻

③ 为什么 forEach 里不能用 await？（必挂题）

[1, 2, 3].forEach(async (i) => {
  await delay(1000)
  console.log(i)
})

表现：
	•	不按顺序
	•	外部无法 await
	•	看起来“失效”

⸻

根本原因（面试官想听）

forEach 不会等待回调函数返回的 Promise

也就是说：

forEach(() => Promise)
👉 forEach 当你写的是普通同步函数

⸻

正确写法（3 种）

✅ 串行
for (const i of arr) {
  await fn(i)
}

✅ 并行
await Promise.all(arr.map(i => fn(i)))

❌ 永远不要
arr.forEach(async () => {})

④ async 函数 return 的到底是什么？

标准答案

async 函数永远返回 Promise


举例
async function f() {
  return 100
}

f().then(res => console.log(res)) // 100

等价于：
function f() {
  return Promise.resolve(100)
}


⸻

抛错等价关系（必考）
async function f() {
  throw new Error('err')
}

等价于：

function f() {
  return Promise.reject(new Error('err'))
}

⑤ 终极混合必杀题（95% 人翻车）

async function test() {
  console.log(1)
  await Promise.resolve()
  console.log(2)
}

console.log(3)

test()

Promise.resolve().then(() => console.log(4))

console.log(5)
正确输出顺序：
3
1
5
2
4


⸻

拆解思路（你面试时要这样说）
	1.	同步代码先执行：3 → 1 → 5
	2.	await 后的代码进 微任务
	3.	Promise.then 也是 微任务
	4.	微任务按注册顺序执行：2 → 4

⸻

面试官收官评语级总结（背）

async/await 只是 Promise 的语法糖，await 会把后续代码放进微任务队列。多个 await 默认串行执行，forEach 不会等待 Promise，async 函数始终返回 Promise。