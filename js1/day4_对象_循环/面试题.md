Q: 为什么直接赋值对象变量，修改副本也会改变原对象？

| 1️⃣ 基本概念：值类型 vs 引用类型 | 在 JavaScript 中，变量分为两类 |
| --- | --- |
| 类型 | 存储方式 |
| 特点 | 基本类型（Number、String、Boolean、null、undefined、Symbol、BigInt） |
| 栈（stack） | 赋值会复制 值本身，互不影响 |
| 引用类型（Object、Array、Function） | 堆（heap） + 栈存地址 |
赋值是复制 引用（地址），修改副本会影响原对象

---

2️⃣ 例子演示

```js
let obj1 = { a: 1, b: 2 };
let obj2 = obj1; // 复制引用，而不是对象本身
```

obj2.a = 100;

```js
console.log(obj1.a); // 100
```

解释：1. obj1 在内存中开辟一个对象 {a:1, b:2}。2. obj2 = obj1 并不是创建新对象，而是把 obj1 的 地址 复制给 obj2。3. 所以 obj1 和 obj2 指向同一个对象，修改其中一个会影响另一个。

3️⃣ 如果想要复制对象而不影响原对象

浅拷贝（只复制一层属性）

```js
let obj2 = { ...obj1 }; // 使用展开运算符
let obj3 = Object.assign({}, obj1); // 使用 Object.assign
```

注意：如果对象里有嵌套对象，浅拷贝的内层对象仍然是共享的。

```js
let obj1 = { a: 1, b: { c: 2 } };
let obj2 = { ...obj1 };
```

obj2.b.c = 100;

```js
console.log(obj1.b.c); // 100 —— 内层对象仍然共享
```

深拷贝（复制整个对象，包括嵌套）

```js
let obj2 = JSON.parse(JSON.stringify(obj1));
```

或者用更高级的深拷贝库（如 lodash.cloneDeep）：

```js
import _ from "lodash";
let obj2 = _.cloneDeep(obj1);
```

## 深拷贝后修改副本，不会影响原对象。

✅ 总结

- 对象赋值只是复制 引用地址，所以修改副本会影响原对象。
- 如果想避免这种情况，需要使用 浅拷贝 或 深拷贝，根据嵌套层级选择。
