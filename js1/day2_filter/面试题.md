为什么 filter 一定要返回新数组，而不是原数组？

1️⃣ filter 的行为
它的作用是 遍历原数组，对每个元素执行 callback，并 返回一个新的数组，只包含 callback 返回 true 的元素。

2️⃣ 为什么必须返回新数组，而不是直接改原数组？

原因主要有四个：
⸻
(1) 函数式编程风格
filter 是典型的函数式方法，函数式编程强调 不修改原数据（immutable），保证 纯函数：
	•	输入相同 → 输出相同
	•	不产生副作用（不改原数组）

如果 filter 直接修改原数组，那么它就带有副作用了，容易导致意外的 bug，尤其在多人协作或者链式调用时。
const arr = [1,2,3,4];
const res = arr.filter(n => n > 2);
res.push(5);
console.log(arr); // 如果修改原数组，这里 arr 也会被改

使用新数组就可以安全链式调用：

const arr = [1,2,3,4];
const res = arr.filter(n => n > 2).map(n => n * 2);
⸻
(2) 兼容链式操作
如果 filter 改变原数组，链式调用就会出现不可预期的结果。比如：
const nums = [1,2,3,4];
nums.filter(n => n > 2).map(n => n * 2);

	•	现在 filter 返回新数组 → map 可以在结果上安全操作
	•	如果 filter 改原数组 → nums 被修改，可能影响其他地方的数据


⸻

(3) 避免遍历过程中破坏数组
假设 filter 想直接改原数组：
	•	你一边遍历原数组，一边删除不满足条件的元素
	•	会导致 索引错位问题，某些元素被跳过或重复判断

let arr = [1,2,3,4];
for(let i=0; i<arr.length; i++){
    if(arr[i] % 2 === 0) arr.splice(i,1);
}

	•	结果不是你想的 [1,3]，因为删除元素会导致数组长度和索引变化。
	•	filter 返回新数组就完美解决这个问题。


⸻

(4) API 一致性
	•	JavaScript 还有 map、reduce 等方法，都遵循 不修改原数组 → 返回新结果
	•	forEach 是唯一会遍历数组但不返回新数组的方法。
	•	filter 遵循这种模式，符合开发者预期。

✅ 总结

filter 返回新数组而不改原数组，是为了：
	1.	保持纯函数、无副作用（immutable）
	2.	支持链式操作
	3.	避免遍历中修改数组导致索引问题
	4.	保持 API 一致性
filter 永远返回新数组，是为了 安全、纯函数、可链式调用，而直接修改原数组容易出错，索引错位，副作用太多。