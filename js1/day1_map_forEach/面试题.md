Q：❓为什么 forEach 没返回值？
forEach 的设计目的不是“生成新数组”，而是“执行副作用操作”，所以它固定返回 undefined。

forEach是为了遍历并执行副作用而设计的数组方法，他不会收集回调函数的返回值，因此始终返回undefined.
如果需要基于原数组生成新的数组， 应使用map/filter/reduce，这也是js对数组遍历和数据变换职责分离的体现
“forEach 是过程式，map 是函数式”

Q：❓那为什么 for…of 有返回值？

因为它是语法结构，不是函数

控制权在你手里：

- break
- continue
- return（在函数里）

Q： 为什么 forEach 不能 async/await 顺序执行

forEach 不会等待 async 回调执行完成，它不会处理 Promise，因此 await 在 forEach 中是“无效的”。

- forEach 是同步执行
- 它 不会接收 / 不会等待 / 不会处理 Promise
- 回调是不是 async，它完全不关心

forEach 是同步遍历方法，不会等待回调函数返回的promise
既是回调是async, forEach 也会立即执行所有迭代，因此无法实现await的顺序控制
若需要顺序执行异步任务，应使用for。。。of 或基于reduce的promise链

Q： 为什么 React / Vue 渲染列表前，常常先用 map？
因为 React / Vue 的渲染本质是：数据 → 视图，而 map 正好是「把数据映射成视图结构」的最合适工具。
1️⃣ 渲染列表 = 数据映射（Mapping）
📌 语义完全一致
2️⃣ map 是“纯函数”，符合 UI 渲染哲学
map 的特点：

- 不修改原数组（不可变）
- 输入确定 → 输出确定
- 无副作用

这正是 React / Vue 推崇的声明式 UI 思想
UI = f(state)
3️⃣ map 会返回新数组（这是关键）
渲染需要的是一个结果集合：
📌 React/Vue 渲染必须“有返回值”
4️⃣ map + key，完美配合 diff 算法
这样：

- 每一项都是独立 VNode
- key 可用于快速 diff
- 避免整列表重渲染
- map 天生适合生成“稳定、有序”的节点集合

5️⃣ React / Vue 官方示例都在“强推 map”
v-for 的底层思想，本质也是 对数组做映射

map 是“数据 → 视图”的最小语义单位，而 UI 框架的本质就是对映射结果做 diff。

Q：那为什么不用 reduce？
reduce 更偏向“聚合计算”，map 语义更清晰，渲染场景可读性更好，reduce 一般用于复杂列表拼装或条件渲染。
