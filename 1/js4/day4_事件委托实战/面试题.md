1️⃣ 事件委托为什么能处理动态元素？

核心原理：事件委托依赖 事件冒泡机制。
	•	当子元素触发事件时，事件会沿 DOM 树向上冒泡，最终会被绑定在父元素上的事件监听器捕获。
	•	因为父元素的事件监听器是在事件冒泡阶段捕获到事件的，它并不关心子元素是否在绑定时已经存在。
	•	所以，即使子元素是动态创建的（页面渲染后才插入 DOM），事件依然会冒泡到父元素，触发回调。

	const ul = document.querySelector('ul');

ul.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    console.log('点击了 li 元素：', e.target.textContent);
  }
});

即使 <li> 是动态添加的，也能被捕获到。

✅ 面试加分点：核心是冒泡机制 + 事件代理父元素捕获事件。


2️⃣ 为什么事件委托比每个元素单独绑定性能好？

原因：
	1.	减少内存占用
	•	每个元素绑定事件会创建一个函数引用，浏览器需要为每个监听器维护事件队列。
	•	如果有成百上千的元素，内存开销明显增加。
	•	委托只在父元素绑定一次，节省内存。
	2.	减少 DOM 操作开销
	•	动态生成或移除元素时，不需要反复绑定/解绑事件。
	•	对动态列表性能友好。
	3.	批量管理方便
	•	一个父级统一处理，逻辑更集中，利于维护。

总结一句话：

事件委托通过共享父级事件监听器，避免了大量重复绑定，性能更高。

⸻

3️⃣ 如果父元素也有 click 事件，会影响委托吗？（如何控制？）

问题分析：
	•	假设父元素本身绑定了 click，同时又作为事件委托容器。
	•	当子元素点击时：
	1.	子元素事件触发 → 冒泡到父元素 → 父元素委托回调触发。
	2.	父元素自身绑定的 click 事件也会触发。
	•	可能会出现重复执行或干扰逻辑。

控制方法：
	1.	判断事件源
	•	使用 e.target 区分实际触发元素和绑定元素：

	parent.addEventListener('click', (e) => {
  if (e.target.matches('.child')) { // 只处理特定子元素
    console.log('处理子元素点击');
  }
});

	2.	阻止冒泡（按需）
	•	如果不希望父元素的其他事件被触发，可在子元素处理函数中使用：
	e.stopPropagation();


		3.	事件捕获 vs 冒泡
	•	默认是冒泡阶段处理，明确使用捕获阶段也可避免逻辑冲突：

	parent.addEventListener('click', handler, true); // true 表示捕获阶段


✅ 面试加分点：能描述 e.target + matches 判断 + stopPropagation 控制冲突，说明理解冒泡机制。

⸻

💡 总结记忆口诀：

委托靠冒泡，动态元素不怕；减少重复绑定，性能高又稳；父元素有冲突，target 区分 + 阻止冒泡。

⸻
