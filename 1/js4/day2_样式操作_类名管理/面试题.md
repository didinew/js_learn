---
1️⃣ element.style.width vs getComputedStyle(element).width 区别
| 特性 | element.style.width | getComputedStyle(element).width | 读取值来源 |
| --- | --- | --- | --- |
| 内联样式（style=""） | 最终渲染样式（computed style），包含 CSS 文件 / 内联 / 浏览器默认值 / 继承等计算结果 | 返回值示例 | "100px"（如果是内联设置了宽度） |
| "100px"（计算后的实际值，精确到渲染结果） | 未设置值时 | ""（空字符串） | 计算出的实际值，例如 200px |
修改效果
只会修改元素的内联样式，优先级高于外部 CSS
只读，无法通过 getComputedStyle 修改 DOM 样式

💡 总结：
- 想读取渲染后的最终宽度 → getComputedStyle
- 想修改或读取内联样式 → element.style
---
2️⃣ classList.add vs 直接修改 className

| 特性 | classList.add('foo') | element.className = 'foo bar' | 作用 |
| --- | --- | --- | --- |
| 增加一个（或多个）类名，不影响已有类 | 直接覆盖原有所有类名 | 安全性 | 自动去重，避免重复类 |
| 会替换原本的类，可能不小心覆盖掉其他样式 | 可操作性 | 可以 .remove()、.toggle()、.contains() | 需要手动字符串拼接/正则操作 |
性能
原生 DOM 方法，性能略优，适合频繁修改
每次都要重新赋值整个 class 字符串

💡 总结：
- 频繁增删类 → classList
- 简单覆盖类 → className
---
3️⃣ 批量修改 style 如何避免多次重排（reflow）

问题：
每次修改元素的 style（比如 width、height、top 等）会触发浏览器重排，如果一次循环里修改大量元素，会导致性能下降。

| 优化方式 | 1.	使用文档碎片 / 临时容器 |
| --- | --- |
| const fragment = document.createDocumentFragment(); | for (let i = 0; i < 1000; i++) { |
| const div = document.createElement('div'); | div.style.width = '100px'; |
| fragment.appendChild(div); | } |
| document.body.appendChild(fragment); // 一次性渲染，避免 1000 次重排 | 2.	使用 class 或 cssText 一次性修改 |
| // 使用 class 统一样式 | element.classList.add('new-style'); |
| // 或使用 cssText 一次性修改 | element.style.cssText += 'width:100px; height:100px;'; |
	3.	使用 requestAnimationFrame 或批量操作

	requestAnimationFrame(() => {
    elements.forEach(el => el.style.width = '100px');
});

	4.	读-写分离
| // 不要读写交错，否则会强制同步回流 | // ❌ BAD |
| --- | --- |
| const width = el.offsetWidth; | el.style.width = width + 'px'; |
| // ✅ GOOD: 先批量读取，再批量写入 | const widths = elements.map(el => el.offsetWidth); |
elements.forEach((el, i) => el.style.width = widths[i] + 'px');

💡 核心原则：

尽量合并 DOM 写操作，避免每次写操作都触发回流。
