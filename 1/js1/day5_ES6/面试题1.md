❌ 必挂题 1（模板字符串）

❓ 题目

下面代码会输出什么？为什么？

```js
const user = {
name: 'Tom',
age: 18
};


function log(strings, ...values) {
console.log(strings);
console.log(values);

}

## log`用户：${user.name}，年龄：${user.age}`;
```
❌ 90% 人会挂的回答

“这是模板字符串，${} 会被替换成变量”

❌ 不合格

- 因为题目根本不是问模板字符串拼接结果

---

✅ 标准答案（满分）

输出结果

strings = ['用户：', '，年龄：', '']
values = ['Tom', 18]

原因解释

- 使用的是 标签模板（Tagged Template）
- 模板字符串会被拆成：
- 静态字符串数组（strings）
- 表达式结果数组（values）
- 并传给 log(strings, ...values)

🎯 面试官真实考点

- 你是否知道 模板字符串不只是字符串拼接
- 是否理解 模板解析阶段
- 是否见过 styled-components / i18n / 安全模板
- 一句话加分

## 模板字符串在底层会被拆分为字符串片段和表达式值，供标签函数二次处理。

❌ 必挂题 2（解构参数）

❓ 题目

下面两段代码有什么区别？哪一个更安全？为什么？

// A

```js
function fetchData(options) {
const url = options.url;
const method = options.method || 'GET';


}


function fetchData({ url, method = "GET" }) {}
```

❌ 常见错误回答

“B 更简洁”

## ❌ 只说简洁 = 挂

✅ 标准答案（面试官满意）

核心区别 1：默认值触发条件不同

options.method || 'GET'

- ''、0、false 都会被错误兜底

  method = 'GET'

- 只有 undefined 才会触发默认值

核心区别 2：B 在参数语义上更明确

```js
fetchData({ url, method });
```

- 调用点即文档
- 不依赖参数顺序

---

核心区别 3（⚠️ 必杀点）

❌ B 会直接报错：

```js
fetchData(); // Cannot destructure property 'url' of undefined
```

✅ 正确写法：

```js
function fetchData({ url, method = "GET" } = {}) {}
```

- 90% 人忘了这个

---

🎯 面试官真实考点

- 是否理解 解构默认值只对 undefined 生效
- 是否能写出 健壮函数
- 是否有真实工程经验

---

🧠 面试官追问（隐藏杀招）

❓ 为什么解构参数在组件中更推荐？

标准答：

## 解构参数让组件 API 更明确，减少内部依赖，避免滥用 props，对维护和重构更友好。

🔥 终极一句话总结（直接背）

模板字符串不仅是字符串拼接工具，还支持标签函数，能在编译阶段拆分字符串和表达式；
解构参数让函数调用具备语义性，并且通过默认值机制避免传统逻辑兜底的隐患。
