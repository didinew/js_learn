
⸻

① 基础默认绑定
function foo() {
  console.log(this)
}
foo()

✅ 答案
	•	非严格：window
	•	严格：undefined

📌 原因：普通函数默认绑定

⸻

② 对象方法调用

const obj = {
  name: 'obj',
  foo() {
    console.log(this.name)
  }
}
obj.foo()

✅ 答案
	•	输出：obj

📌 原因：隐式绑定


⸻

③ 隐式丢失

const obj = {
  name: 'obj',
  foo() {
    console.log(this.name)
  }
}
const f = obj.foo
f()
✅ 答案

undefined / window.name

📌 原因：脱离对象调用

⸻

④ 隐式丢失（回调地狱）

const obj = {
  name: 'obj',
  foo() {
    setTimeout(function () {
      console.log(this.name)
    }, 0)
  }
}
obj.foo()

✅ 答案
undefined

📌 原因：回调函数默认绑定


⸻

⑤ 箭头函数修复 this

const obj = {
  name: 'obj',
  foo() {
    setTimeout(() => {
      console.log(this.name)
    }, 0)
  }
}
obj.foo()

✅ 答案
	•	输出：obj

📌 原因：箭头函数继承外层 this

⸻

⑥ 显式绑定 call
function foo() {
  console.log(this.name)
}
foo.call({ name: 'call' })
✅ 答案
call

📌 原因：call 方法指定 this 指向


⸻

⑦ bind 永久绑定

function foo() {
  console.log(this.name)
}
const bar = foo.bind({ name: 'bind' })
bar.call({ name: 'call' })
✅ 答案
bind
📌 原因：bind 最高优先级（仅次于 new）


⸻

⑧ new vs bind

function Foo() {
  this.name = 'foo'
}
const Bar = Foo.bind({ name: 'bind' })
const b = new Bar()
console.log(b.name)
✅ 答案
foo

📌 原因：new 绑定优先级最高


⸻

⑨ 箭头函数 + bind

const foo = () => {
  console.log(this.name)
}
foo.bind({ name: 'bind' })()
✅ 答案
undefined
📌 原因：箭头函数 this 不可绑定

⸻

⑩ 多层对象调用

const obj = {
  name: 'obj',
  foo() {
    return {
      name: 'inner',
      bar() {
        console.log(this.name)
      }
    }
  }
}
obj.foo().bar()
✅ 答案
inner

⸻

⑪ 多层对象 + 箭头函数

const obj = {
  name: 'obj',
  foo() {
    return {
      name: 'inner',
      bar: () => {
        console.log(this.name)
      }
    }
  }
}
obj.foo().bar()
✅ 答案
obj
📌 原因：箭头函数继承 foo 的 this

⸻

⑫ 原型方法 this

function Person(name) {
  this.name = name
}
Person.prototype.say = function () {
  console.log(this.name)
}

const p = new Person('DiDi')
p.say()
✅ 答案
DiDi
📌 原因：this 指向调用者实例

⸻

⑬ 原型方法丢失 this
const say = p.say
say()
✅ 答案
undefined
📌 原因：脱离实例调用


⸻

⑭ class 中的 this
class A {
  constructor() {
    this.name = 'A'
  }
  foo() {
    console.log(this.name)
  }
}
const a = new A()
const f = a.foo
f()
✅ 答案
undefined
📌 原因：class 默认严格模式


⸻

⑮ 终极混合题（面试官最爱）
var name = 'global'

const obj = {
  name: 'obj',
  foo() {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}

const fn = obj.foo()
fn()
✅ 答案
obj
obj
📌 原因：
	•	foo：隐式绑定 → obj
	•	返回箭头函数 → 继承 foo 的 this

🧠 终极判断口诀（背）

先看有没有 new
再看 bind / call / apply
再看是不是对象调用
最后默认绑定
箭头函数直接看定义处
