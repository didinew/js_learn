💣 原型陷阱题（请先别急着看答案）

```js
function Foo() {}
```

Foo.prototype.a = 1

```js
const obj1 = new Foo();
const obj2 = new Foo();
```

obj1.a = 2

```js
console.log(obj1.a); // ?
console.log(obj2.a); // ?
```

❌ 99% 的错误答案

2
2

❌ 原因：

“a 在 prototype 上，改了一个实例，大家都会变”

这是错的。
✅ 正确答案
2
1

---

🧠 为什么？（原型链执行全过程）

| 1️⃣ 初始结构 | obj1 obj2                |
| ----------- | ------------------------ |
| │ │         | │**proto** │**proto**    |
| ▼ ▼         | Foo.prototype = { a: 1 } |

---

2️⃣ 执行这一句（致命点）
obj1.a = 2

🔴 发生了什么？

并不是修改 prototype 上的 a
而是：
在 obj1 自身上创建了一个新的属性 a

现在结构变成 👇

obj1 = { a: 2 } obj2 = {}
│ │
└── **proto** └── **proto**
▼ ▼
Foo.prototype = { a: 1 }

---

3️⃣ 再看取值顺序（面试加分点）
obj1.a

查找顺序：1. 先找 obj1 自身 → 找到 a = 2 ✅ 2. 不会再往 prototype 上找

obj2.a

1. obj2 自身没有 a
2. 去 prototype → 找到 a = 1 ✅

---

🔥 一句话必杀总结（直接背）

“读取属性会沿原型链向上找，
但给实例赋值，只会作用在实例本身，不会影响原型。”

🧨 面试官升级追问（90% 直接崩）

❓ 那如果是这样呢？
Foo.prototype.b = { x: 1 }

obj1.b.x = 2

```js
console.log(obj2.b.x); // ?
```

- 正确答案是：
  2
  ❗ 因为这次没有改引用指向，只是改了引用内部的值

---

🧠 终极区分口诀（原型地狱逃生用）

| 操作                   | 结果          | obj.a = xxx      |
| ---------------------- | ------------- | ---------------- |
| 在 obj 上创建/覆盖属性 | obj.a.x = xxx | 修改共享引用对象 |
| 读属性                 | 沿原型链找    | 写属性           |

永远只写当前对象
