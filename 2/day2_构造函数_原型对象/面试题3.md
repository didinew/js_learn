
⸻

题 1：实例属性 vs 原型属性

function Foo() {}
Foo.prototype.a = 1;

const obj = new Foo();
obj.a = 2;

console.log(obj.a);         // ?
console.log(Foo.prototype.a); // ?
✅ 答案
obj.a       // 2
Foo.prototype.a // 1

🧠 核心解析
	1.	读取：先找实例属性，没有再找原型。
	2.	赋值：在实例上新建或覆盖，不影响原型。
	3.	口诀：读“原型链”，写“当前对象”。

⸻

题 2：共享引用类型陷阱
function Foo() {}
Foo.prototype.arr = [];

const obj1 = new Foo();
const obj2 = new Foo();

obj1.arr.push(1);

console.log(obj2.arr); // ?

✅ 答案
[1]
🧠 核心解析
	1.	原型属性如果是引用类型（对象 / 数组 / 函数），实例共享同一个引用。
	2.	修改内部值会影响所有实例。
	3.	区分：赋值 vs 修改内部值
	•	obj1.arr = [] → 实例独立
	•	obj1.arr.push() → 修改共享数组

⸻

题 3：构造函数 vs 原型链访问顺序

function Foo() {
  this.a = 1;
}
Foo.prototype.a = 2;

const obj = new Foo();
delete obj.a;

console.log(obj.a); // ?

✅ 答案
2
🧠 核心解析
	1.	this.a = 1 → 实例自身有 a
	2.	delete obj.a → 删除实例自身的 a
	3.	读取 obj.a → 沿原型链找，找到 Foo.prototype.a = 2
	4.	必背点：实例属性被删除后，才会回退到原型属性

⸻

🔥 面试必杀总结
	1.	赋值只影响实例，读属性沿原型链找
	2.	引用类型属性在原型上会共享
	3.	删除实例属性 → 会回退到原型属性

面试官可能会再升级追问：
	•	“改引用内部值 vs 改引用本身”
	•	“原型链多层继承”
	•	“class 语法下的同等行为”

