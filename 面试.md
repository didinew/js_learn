既然 props 不能修改，那子组件怎么“改变父组件的 state”？

子组件不能直接修改 props，如果需要影响父组件状态，
由父组件把修改 state 的函数通过 props 传给子组件，
子组件在合适的时机调用这个函数，
实际的状态修改仍然发生在父组件中。

面试官补刀追问 2（区分普通和进阶）

为什么 React 要强制 props 只读？
如果允许子组件随便改 props，会发生什么问题？


1.	单向数据流
	•	数据来源唯一
	•	状态变化路径清晰
	2.	可预测性
	•	状态只在拥有者处修改
	•	不会出现“谁偷偷改了数据”的问题
	3.	调试友好
	•	问题可以沿着 props 链向上追
	•	不需要全局找副作用
	4.	组件职责单一 & 高复用
	•	子组件只关心展示和触发事件
	•	不依赖具体业务状态结构

👉 这是中高级前端才会答到的层级。

面试官进阶追问 3（常出现在二面 / 三面）

那什么情况下，你不应该把状态放在组件的 state 里？
换句话说：状态应该提升（state lifting）的判断标准是什么？

	1.	多个组件需要共享这个状态
	•	状态不属于某一个子组件
	•	应提升到它们最近的公共父组件
	2.	某个组件只是展示，不是真正的状态拥有者
	•	谁负责修改、谁依赖业务逻辑
	•	状态就应该放在谁那里
	3.	状态变化会影响多个组件的渲染或行为
	•	为了保证一致性
	•	避免多个地方维护同一份状态

终极问题答案

面试官终极追问（区分高级）

那什么状态 不应该 提升，
即使多个组件“看起来”都用到了？

1️⃣ 纯 UI 状态（局部即可）

只影响当前组件的展示，不影响业务逻辑

例如：
	•	弹窗是否打开
	•	下拉菜单展开 / 收起
	•	hover / focus 状态
	•	loading 动画

✅ 原因：
	•	和具体组件强绑定
	•	提升只会增加耦合和复杂度

⸻

2️⃣ 派生状态（能算出来的不要存）

可以通过 props 或其他 state 计算得到的状态

例如：
	•	totalPrice = price * count
	•	isEmpty = list.length === 0
	•	isSelected = currentId === id

✅ 原因：
	•	容易产生数据不一致
	•	增加同步成本和 bug

面试官爱听这句：

「派生状态不应该存，应该在渲染时计算」

⸻

3️⃣ 只被单一组件消费的状态

即使父组件也能访问，但没有共享需求

例如：
	•	表单输入中的中间值
	•	临时编辑态草稿

✅ 原因：
	•	状态提升 ≠ 状态集中
	•	状态层级越高，影响面越大

第 4 题（状态设计分水岭）

什么情况下，你会选择 useReducer，而不是 useState？

什么时候用 useReducer 而不是 useState？

1️⃣ 状态逻辑复杂、更新规则多

一个状态的变化依赖多种 action / 条件

例如：
	•	表单有 add / remove / reset / validate
	•	列表有 loading / success / error / retry
	•	复杂流程（下单、审批、步骤流）

✅ 原因：
useReducer 把 “怎么改” 和 “什么时候改” 集中在 reducer 中，逻辑更清晰。

⸻

2️⃣ 多个 state 强相关，需要原子更新

多个状态必须同时变化，不能中间态错乱

例如：

loading = true
data = null
error = null
如果用多个 useState：
	•	容易漏改
	•	容易顺序出错

✅ useReducer：
	•	一次 dispatch
	•	状态一致性更强

⸻

3️⃣ 状态更新依赖上一次状态

更新逻辑不是简单赋值

例如：
	•	计数器带上限 / 下限
	•	undo / redo
	•	分页叠加数据

✅ reducer(state, action) 天然适合这种场景。

⸻

4️⃣ 希望状态逻辑可测试、可复用

reducer 是纯函数

好处：
	•	单元测试简单
	•	可抽离为独立模块
	•	可和 Context / Redux 形态统一

⸻

面试官最爱总结句（记住）

useState 管“值”，useReducer 管“规则”。

面试官追问 5（必追）

useReducer 和 Redux 有什么本质区别？
什么时候只用 useReducer 就够了？

useReducer 和 Redux 的本质区别

1️⃣ 作用范围不同（最核心）
	•	useReducer
	•	作用域：单个组件 / 组件树
	•	状态是局部的
	•	随组件生命周期创建和销毁
	•	Redux
	•	作用域：全局应用
	•	单一 Store
	•	跨页面、跨模块共享

👉 关键词：局部状态 vs 全局状态

⸻

2️⃣ 是否有完整的状态管理体系
	•	useReducer
	•	只有：state + reducer + dispatch
	•	没有：
	•	middleware
	•	devtools
	•	时间旅行
	•	异步规范
	•	Redux
	•	完整体系：
	•	middleware（thunk / saga）
	•	DevTools
	•	时间回溯
	•	严格的数据流约束

⸻

3️⃣ 对异步和副作用的处理方式
	•	useReducer
	•	reducer 必须是纯函数
	•	异步写在组件 / effect 里
	•	Redux
	•	异步通过 middleware 统一管理
	•	业务副作用集中处理

⸻

什么时候「只用 useReducer 就够了」？

✅ 适合 useReducer 的场景
	1.	状态只在某个功能模块内使用
	•	比如一个复杂表单 / 弹窗流程
	2.	不需要跨页面共享
	•	页面卸载即可销毁
	3.	不需要时间旅行 / 调试工具
	•	复杂度可控
	4.	希望减少引入全局状态管理的成本

⸻

面试官一锤定音总结（必背）

useReducer 是 React 自带的“局部 Redux”，
Redux 是完整的“应用级状态管理方案”。


面试官最后加压追问（可选）

那 useReducer + Context 能不能完全替代 Redux？
什么情况下不行？

useReducer + Context 能否完全替代 Redux？

👉 结论先行

不能完全替代，只能覆盖一部分 Redux 使用场景。

⸻

为什么「看起来能替代」？

1️⃣ 核心模型是一样的
	•	reducer（纯函数）
	•	dispatch(action)
	•	单向数据流

useReducer + Context 本质就是：

React 官方版的轻量 Redux

⸻

2️⃣ 中小规模场景完全够用

适合：
	•	全局主题（theme）
	•	登录用户信息
	•	权限 / 语言配置
	•	简单业务状态

⸻

为什么「不能完全替代」Redux？

1️⃣ 性能问题（最关键）
	•	Context 任何 value 变化
	•	所有消费该 Context 的组件 都会重新渲染

Redux：
	•	精准订阅
	•	组件只在 slice 变化时更新

👉 大型应用中，Context 容易成为性能瓶颈。

⸻

2️⃣ 缺乏中间件体系

useReducer + Context：
	•	没有 middleware
	•	副作用散落在各组件

Redux：
	•	thunk / saga / observable
	•	异步、日志、错误统一处理

⸻

3️⃣ 工程化和调试能力不足

缺失：
	•	时间旅行
	•	action 追踪
	•	状态快照
	•	严格规范约束

Redux DevTools 在复杂项目中是“救命工具”。

⸻

4️⃣ 状态规模扩大后，维护成本爆炸

Context 多了会：
	•	嵌套地狱
	•	Provider 层级混乱
	•	状态边界不清晰

Redux：
	•	结构清晰
	•	slice 拆分明确
	•	可长期维护

⸻

面试官最终总结句（必杀）

useReducer + Context 是“方案”，
Redux 是“体系”

