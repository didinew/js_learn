❓问题 1
computed 的 getter 是在什么时候执行的？
computed 的 getter 是在“第一次被访问时”执行的，而不是在定义或注册时。
它是一个 lazy effect，会在首次访问时执行并缓存结果，之后只有当依赖变化并再次访问时才会重新计算。

依赖变化本身不会立即触发 getter 执行，只会把 computed 标记为 dirty。

❓问题 2（马上接）
那 computed 依赖变了，为什么不立刻重新执行 getter？

因为 computed 是 lazy effect。依赖变化时不会立刻执行 getter，而只是把 computed 标记为 dirty。只有在下一次访问时才重新计算，以避免无意义的计算开销。

❓问题 3（对比致命题）

那你说说：computed 和 watch 在调度机制上有什么本质区别？


computed：第一次访问时执行 getter 并缓存结果，依赖变化时只标记 dirty，不会立刻执行，下一次访问才计算，适合派生值。
watch：不产生派生值，依赖变化时立即执行回调，用于处理副作用。

核心区别：computed 是懒执行、缓存派生值，watch 是即时执行副作用。

⸻

❓问题 4（深水追杀）

那你说说 为什么不推荐 deep watch？
并且从 性能 / 可控性 / 精度 三个维度解释。

deep watch 会递归遍历对象的所有嵌套属性，一旦任意属性变化就触发回调，造成性能浪费。同时无法精准定位是哪一项变化，导致可控性和精度低。线上项目中容易引起重复执行和内存开销，因此不推荐使用。
替代方案：拆分成多个精确的 watch，或者监听派生值。

❓问题 5（陷阱追问）

computed 能不能有副作用？
如果有，会有什么问题？
computed 必须是纯函数，不能有副作用。因为 computed 值依赖缓存和可预测性，一旦在 getter 里有副作用，会导致重复执行、状态混乱、缓存失效，不可控。副作用应该放到 watch 或 watchEffect 中处理。

❓问题 6（高级追杀）

那 computed 的 setter 算副作用吗？
如果 setter 里修改其他响应式值，会怎么样？

computed 的 setter 不算副作用，因为它是显式触发的状态修改入口，而不是 getter 中的隐式副作用。
如果 setter 修改了其他响应式值，可能会导致缓存失效，但这是可控行为，不影响 computed 的纯粹性。
❓终极问题（压力面收尾）

结合你说的这些，解释一下 computed / watch / watchEffect 的职责划分，以及在实际项目中怎么选用。

computed 适合需要缓存的派生值，它的 getter 是纯函数且懒执行，保证性能和可预测性。
watch 适合处理依赖变化立即响应的副作用，比如表单状态变化、接口请求、定时器等，它会在依赖变化时立即执行回调。
watchEffect 适合依赖不明确、逻辑简单的场景，它会自动收集依赖并立即执行。
在实际项目中，核心业务逻辑优先用 watch 保持可控，watchEffect 用于快速实验或组合多个响应式源。

🎯 总结压面口诀（15 秒背完）

computed → 缓存派生值
watch → 精确副作用
watchEffect → 自动依赖实验

⚡ 核心概念记住：
	•	computed = lazy effect + 缓存
	•	watch = 精准监听 + 立即执行
	•	deep watch = 性能杀手
	•	computed getter = 纯函数，setter 是可控修改入口
