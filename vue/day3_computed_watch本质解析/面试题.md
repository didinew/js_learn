1️⃣ computed 为什么有缓存？

一句话答案

computed 是基于依赖的懒执行 + 缓存机制，只在依赖变化时才重新计算。

⸻

核心原理（面试官最爱）
	•	computed 内部是一个 lazy 的 effect
	•	第一次访问：
	•	执行 getter
	•	收集依赖
	•	结果缓存
	•	依赖未变：
	•	直接返回缓存值
	•	依赖变了：
	•	仅标记为 dirty
	•	下次访问才重新计算

  const total = computed(() => price.value * count.value)

  ✔ 依赖没变 → 不执行
✔ 依赖变了 → 标脏，但不立刻算

⸻

面试官追问 💣

那 watch 为什么没有缓存？

标准反杀

watch 的目标是「响应变化做事」，不是「派生新值」，所以每次变化都要执行回调，没有缓存意义。

⸻

2️⃣ watch 和 watchEffect 的核心区别？

一句话对比
对比项
watch
watchEffect
依赖来源
显式指定
自动收集
执行时机
默认不立即
立即执行
oldValue
✅ 有
❌ 没有
可控性
⭐⭐⭐⭐⭐
⭐⭐⭐


⸻

watch：你告诉它看谁
watch(
  () => state.count,
  (newVal, oldVal) => {}
)
✔ 精准
✔ 可控
✔ 适合业务逻辑

⸻

watchEffect：自己跑进去“摸”依赖
watchEffect(() => {
  console.log(state.count)
})
✔ 自动依赖
✔ 立即执行
❌ 依赖不清晰
❌ 容易误触发

⸻

面试官追问 💣

什么时候用 watchEffect？

满分回答

在依赖不确定、快速试验、组合多个响应式源时使用；核心业务逻辑优先 watch。

⸻

3️⃣ 为什么不推荐 deep watch？

一句话结论

deep watch 性能差、不可控、调试困难。

⸻

原因拆解（非常关键）

1️⃣ 性能问题
watch(obj, () => {}, { deep: true })

👉 会 递归遍历所有嵌套属性
👉 对大对象极其致命

⸻

2️⃣ 精度丢失
oldValue === newValue // true
因为对象是同一个引用

⸻

3️⃣ 触发不可控
obj.a.b.c.d++
❌ 不知道谁动了
❌ 不好维护

⸻

推荐方案（面试加分）
watch(() => obj.a.b, ...)
watch(() => obj.list.length, ...)
watch 精确依赖，而不是“监控一切”。

⸻

4️⃣ computed 能不能有副作用？

标准答案（必须斩钉截铁）

不能，computed 必须是纯函数。

⸻

为什么？
	•	computed 的设计目标是：
	•	派生值
	•	可缓存
	•	可预测
	•	副作用会导致：
	•	重复执行
	•	隐式状态修改
	•	调试地狱

⸻

❌ 错误示例（面试必挂）
const total = computed(() => {
  console.log('log')
  fetchData()
  return price.value * count.value
})

⸻

✅ 正确职责划分
场景
用什么
派生值
computed
异步 / 副作用
watch
自动依赖副作用
watchEffect

面试官终极追问 💣

那 computed 的 setter 算副作用吗？

满分反杀

不算。setter 是显式触发的状态修改入口，不是 getter 中的隐式副作用。

⸻

🎯 面试速背版（30 秒）

	•	computed：懒执行 + 依赖缓存
	•	watch：精确监听，适合业务
	•	watchEffect：自动依赖，适合探索
	•	deep watch：性能差，不推荐
	•	computed：必须纯，不能有副作用