一句话先给结论

memo 化（memoization）
👉 缓存组件的渲染结果 / 计算结果，当输入（依赖）不变时，直接复用上一次结果，不再重新执行。

在组件层面：

父组件更新 ≠ 子组件一定重新渲染
只要子组件的 输入没有变，就可以被“跳过”。

⸻

一、为什么父组件更新，子组件默认会更新？

在 Vue 中：
	•	父组件 render() 重新执行
	•	会 重新创建子组件 vnode
	•	默认会认为：
“子组件可能依赖父组件的变化”
	•	所以子组件也会进入更新流程

⚠️ 注意：
是“进入更新流程”，不等于 DOM 一定重绘

⸻

二、memo 化在 Vue 里是什么意思？

让 Vue 知道：这个组件 / 这段渲染，在依赖不变时，可以直接复用

Vue 提供了 3 个层级的 memo 化手段

⸻

三、组件级 memo 化（最重要）

1️⃣ v-memo（Vue 3.3+）

最直接的 memo 化手段

<Child v-memo="[count]" :count="count" />
含义：

只有当 count 变化时，Child 才会重新渲染
否则直接复用上一次 vnode

✅ 这是最接近 React.memo 的东西

📌 本质：
	•	Vue 比较 v-memo 里的依赖
	•	没变 → 跳过子组件 patch

⸻

2️⃣ defineComponent + props 稳定性

如果：

<Child :user="user" />

但你每次都这样：

const user = { name: 'Tom' } // 每次 render 都是新对象
❌ 即使内容一样，也会触发更新

正确 memo 化方式：

const user = computed(() => rawUser)
或：

const user = shallowRef(rawUser)
👉 保持 props 引用稳定 = 隐式 memo

⸻

四、计算层 memo 化（computed）

❌ 没 memo

function double() {
  return count.value * 2
}
每次 render 都会执行

⸻

✅ computed = 自动 memo

const double = computed(() => count.value * 2)
特点：
	•	依赖不变 → 不重新计算
	•	依赖变化 → 才重新算

📌 这是 Vue 中 最经典、最安全的 memo 化

⸻

五、渲染层 memo（静态提升 / hoist）

Vue 编译阶段会自动做：

<div>我是静态内容</div>

➡️ 提升成：

const _hoisted_1 = createElementVNode("div", null, "我是静态内容")
之后 render：
	•	父组件更新
	•	这段 不会重新创建

这是 编译期 memo

⸻

六、对比总结（面试可直接背）

场景
memo 手段
子组件不想跟父组件一起更新
v-memo
计算值不想重复算
computed
props 不想引发无效更新
保持引用稳定
静态内容
编译期 hoist
大列表
key + v-memo


⸻

七、面试官追问必杀回答

Q：memo 化解决的核心问题是什么？

标准回答：

memo 化的本质是
用“依赖是否变化”换“是否重新执行渲染或计算”
目的是减少无意义的 render / patch / diff。

⸻

Q：什么时候不适合 memo？

✔️ 你可以这样答：

当组件：
	•	内部依赖复杂
	•	副作用多
	•	或 props 高频变化
过度 memo 反而增加比较成本，得不偿失。

⸻

八、一句话终极总结

memo 化不是不更新，而是“该更新才更新”


⸻

追问 ①

父组件更新，子组件一定会重新渲染吗？

❌ 错误回答（初级）

会，只要父组件更新，子组件就会更新。

✅ 标准满分回答

不一定。
父组件更新时，子组件默认会进入更新流程，但是否真正重新渲染，取决于：
	•	子组件的 props 是否变化
	•	是否被 v-memo / 静态提升 / 稳定引用 等机制命中

如果子组件的输入没有变化，Vue 可以直接复用上一次的渲染结果，跳过 patch。

📌 加分点

“进入更新流程 ≠ DOM 一定重绘”

⸻

追问 ②

那 Vue 是怎么判断「子组件要不要更新」的？

❌ 常见误区

比较 props 深度是否相等

（❌ Vue 不做深比较）

⸻

✅ 满分回答

Vue 判断是否需要更新，核心看 依赖是否发生变化，包括：
	1.	props 的引用是否变化（浅比较）
	2.	v-memo 指定的依赖是否变化
	3.	子组件自身是否有 响应式依赖触发

如果这些都没变：
	•	子组件 render 不会重新执行
	•	diff / patch 会被跳过

📌 一句话总结

Vue 用的是 “依赖驱动 + 引用稳定性”，不是值对比。

⸻

追问 ③（终极追杀）

既然有 memo，那是不是可以大量用，组件就会更快？

⚠️ 这是 90% 人会掉坑的问题

⸻

❌ 错误回答

是的，memo 越多，性能越好。

⸻

✅ 高级满分回答

不一定。
memo 化本身也有成本：
	•	需要 比较依赖
	•	需要 维护缓存

当组件：
	•	props 高频变化
	•	依赖复杂
	•	或本身渲染成本很低

memo 的收益可能 小于比较成本，反而变慢。

所以 memo 适合用在：
	•	渲染昂贵
	•	依赖稳定
	•	更新频率低 的组件上。

🎯 反杀一句

“memo 不是银弹，而是精确优化工具。”

⸻

面试官最终评价（真实）

👍 理解了 Vue 更新不是‘父传子必更’，而是依赖驱动

👍 知道 memo 的适用边界

👉 这是中高级 Vue 工程师水平

⸻

一张「背下来就稳」的速记卡

父更新 ≠ 子重渲
是否重渲 = 依赖是否变
memo 用对是优化，用错是负担
