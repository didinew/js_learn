🔥 ref vs reactive 面试连环追杀题（真实面试版）

⸻

① 为什么 Vue3 既有 ref 又有 reactive？不能只留一个吗？

✅ 标准回答

ref 主要用于基本类型或单值引用，
reactive 用于对象 / 数组等复杂结构，两者解决的问题不同。

👿 追问 1：那对象我用 ref 行不行？

const obj = ref({ a: 1 })

✅ 高分回答

可以，但 obj.value.a 写法冗余，
reactive 更符合对象操作的直觉。

👿 追问 2：那 Vue 为啥不自动帮我省略 .value？

💣 反杀答案

因为 .value 是 ref 与普通变量的语义边界，
自动省略会导致赋值、传参时产生歧义，破坏响应式可控性。

⸻

② ref 和 reactive 在底层实现上最大的区别是什么？

✅ 标准回答

ref 基于 getter / setter（Object.defineProperty 思路），
reactive 基于 Proxy 拦截整个对象。

👿 追问：那 ref 里如果包的是对象呢？

const obj = ref({ a: 1 })

💣 满分反杀

.value 本身是 ref 的 getter/setter，
而 .value 内部的对象会被 自动转成 reactive，
所以 obj.value.a 仍然是 Proxy 响应式。

⸻

③ reactive 为什么不能直接解构？ref 却可以？

👿 面试官先给代码

const state = reactive({ count: 0 })
const { count } = state

❌ 错误原因

解构会读取一次值，断开 Proxy → key 的依赖链。

✅ ref 的情况

const count = ref(0)
const { value } = count

💣 反杀话术

reactive 的响应式依赖绑定在「对象 + key」上，
解构会丢失 key 维度；
ref 的依赖只在 .value 上，因此不会有同样的问题。

⸻

④ 为什么 setup 里 return 的 ref，模板里不用 .value？

👿 追问：那 reactive 为什么不用解包？

💣 满分回答

模板只对 ref 做自动 unref，
因为 reactive 本身就是 Proxy，已经是“展开态”，
再解包反而会破坏属性访问语义。

⸻

⑤ ref 和 reactive 的依赖收集粒度有什么区别？

✅ 标准回答

类型
依赖维度
ref
对象本身 + .value
reactive
对象 + 属性 key

👿 追问：哪个更细？

💣 满分反杀

reactive 是 属性级别依赖，更新更精准；
ref 是 值级别依赖，但语义更清晰，适合单值状态。

⸻

⑥ 为什么 computed / watch 默认更偏向 ref？

👿 面试官追问

computed 明明也是 reactive 数据啊？

💣 满分答案

因为 computed 的本质是「返回一个可被依赖追踪的值」，
用 ref 能天然表达「单一派生值」，
同时避免 reactive 带来的结构歧义。

⸻

⑦ reactive 能被替换吗？为什么官方说“优先使用 ref”？

💣 终极反杀话术

组合式 API 中推荐 ref 是因为：
	•	更利于逻辑抽离（函数返回单值）
	•	类型推导更友好（TS）
	•	解构安全
	•	更符合函数式组合心智模型

reactive 更适合 局部状态对象，而不是 API 边界。

⸻

⑧ 最容易翻车的一道终极题（90% 会错）

👿 面试官出题
const state = reactive({ count: 0 })
const count = ref(state.count)

state.count++
console.log(count.value) // ?

❌ 大多数人答：1

✅ 正确答案：0

💣 满分解释

ref(state.count) 只在创建时取值，
并没有建立“引用关系”，
真正的属性级绑定要用 toRef(state, 'count')。

