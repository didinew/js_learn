1️⃣ 为什么 Hooks（组合式函数）比 mixin 更好？

Mixin 的问题：
	1.	命名冲突
多个 mixin 合并时，属性和方法可能覆盖，导致隐式依赖和难排查的 bug。
	2.	隐式依赖
Mixin 内部直接依赖组件的 data / methods，外部很难知道依赖和副作用。
	3.	可读性差
当组件里引入多个 mixin 时，逻辑分散，无法直观看到一个功能模块的完整实现。

Hooks（组合式函数）的优势：
	1.	明确依赖
Hook 内部依赖明确，可以通过参数传入，也可以返回状态，组件使用时一目了然。
	2.	高复用性
Hook 是纯函数，可以多次调用，不会引入命名冲突或隐式污染。
	3.	逻辑集中
功能相关的状态和副作用可以集中在一个 Hook 内，实现“关注点分离”。
	4.	类型友好
TypeScript 可以精准推断 Hook 返回的类型，比 mixin 的类型推断更可靠。

⸻

2️⃣ 副作用如何清理？

在 Vue 3 的组合式 API 中，副作用通常指 watchEffect / watch / 生命周期副作用（例如事件监听、定时器、订阅、DOM 操作等）。

清理方法：
	•	watchEffect 清理函数

	import { watchEffect } from 'vue'

const stop = watchEffect((onCleanup) => {
  const timer = setInterval(() => console.log('tick'), 1000)
  
  onCleanup(() => clearInterval(timer))
})

	•	onCleanup 会在下一次副作用重新执行前调用，也会在组件卸载时调用。
	•	避免内存泄漏。

	•	生命周期钩子清理
	import { onUnmounted } from 'vue'

const timer = setInterval(() => console.log('tick'), 1000)
onUnmounted(() => clearInterval(timer))

总结：副作用清理就是在组件卸载或依赖变化时，及时释放资源，防止内存泄漏和重复执行。

⸻

3️⃣ watchEffect 的 cleanup 是干什么？

watchEffect 的 onCleanup 是专门用来 清理副作用的函数。

原理：
	•	watchEffect 会 立即执行副作用函数，并在依赖变化时重新执行。
	•	如果上一次副作用产生了资源（比如定时器、事件监听、websocket 订阅），就需要先清理，否则会出现重复执行或内存泄漏。
	•	onCleanup(fn) 就是告诉 Vue：“下次重新执行之前，请先调用 fn 清理旧的副作用。”

示例：

watchEffect((onCleanup) => {
  const id = setInterval(() => console.log('tick'), 1000)
  onCleanup(() => clearInterval(id)) // 清理旧定时器
})


⸻

4️⃣ 如何设计一个高复用的 Hooks？

设计原则：
	1.	单一职责
	•	一个 Hook 只做一件事，比如 useFetch, useScroll, useInterval。
	•	避免把太多逻辑堆在一个 Hook 里。
	2.	纯函数 / 参数化
	•	Hook 不依赖组件内部隐式状态，依赖通过参数传入。
	function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  const loading = ref(true)
  // ...
  return { data, error, loading }
}
	3.	返回状态 & 操作函数
	•	返回的数据和操作函数尽量完整，不依赖外部 scope。
	4.	副作用安全
	•	使用 watchEffect 或 watch 时，确保有清理逻辑。
	5.	可组合
	•	Hook 内部可以组合其他 Hook，提高复用性。
	6.	生命周期友好
	•	使用 onMounted / onUnmounted / watchEffect 保证自动挂载和卸载。

示例：可复用倒计时 Hook

import { ref, watchEffect, onUnmounted } from 'vue'

export function useCountdown(start = 10) {
  const count = ref(start)
  let timer = null

  const startCountdown = () => {
    timer = setInterval(() => {
      if (count.value > 0) count.value--
    }, 1000)
  }

  const stopCountdown = () => {
    clearInterval(timer)
  }

  onUnmounted(() => stopCountdown()) // 自动清理

  return { count, startCountdown, stopCountdown }
}


这样 Hook 完全独立、可复用、可组合。

⸻

✅ 总结一句话：
	•	Hooks 优于 mixin：逻辑清晰、依赖显式、类型安全、可组合。
	•	副作用清理：利用 onCleanup 或生命周期钩子，避免重复执行和内存泄漏。
	•	高复用 Hooks：单一职责、参数化、返回状态和操作函数、副作用安全、生命周期友好。

