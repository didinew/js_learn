Q1️⃣：Vue 的通信模型核心是什
Vue 的通信本质是
单向数据流 + 事件回流 + 函数插槽 + 依赖注入。

1️⃣ Vue 通信核心

单向数据流 + 事件回流 + 函数插槽 + 依赖注入

2️⃣ v-model 实现

本质是 props + emit，父传值，子通过 emit 回流更新；多 v-model 独立命名空间避免冲突

3️⃣ scheduler 核心

批量调度 effect，避免同一事件循环内重复执行，保证状态稳定，减少性能浪费

4️⃣ scheduler vs nextTick

scheduler 控制 更新执行时机，nextTick 控制 DOM 安全读取时机；两者职责不同

scheduler 负责的是 副作用的调度阶段，
它决定 哪些 effect 需要执行、何时执行、是否去重。

nextTick 负责的是 状态更新完成后的观察阶段，
它保证回调在 DOM 更新并 flush 完所有调度任务之后 执行。

Vue 通过 scheduler 将 effect 推入一个 基于微任务的队列，
在同一事件循环中完成批量更新；
nextTick 则是向 同一个微任务队列尾部 注册回调，
用来获取 最终稳定状态下的 DOM。

所以 scheduler 解决的是 “什么时候更新”，
nextTick 解决的是 “什么时候可以安全读取更新结果”，
两者职责不同，不能互相替代。


5️⃣ computed 懒执行

computed 是按需计算的 effect，依赖变化只标记 dirty，不立即计算，保证缓存和调度稳定
computed 之所以设计成 懒执行，
是为了保证 依赖收集、调度和缓存语义的稳定性。

computed 本质是一个 带 scheduler 的 effect，
它只有在 被访问时 才会执行，
并在依赖变更时只做一件事：标记 dirty，而不是立即重新计算。

如果 computed 不是懒执行的，
那么每一次依赖 trigger 都会立刻重新求值，
不但会导致 无用计算，
还会破坏 computed 的 缓存语义，
在级联依赖中甚至可能引发 重复执行和调度顺序混乱。

懒执行让 computed 成为一个
“按需计算、可缓存、可组合的派生状态”，
这也是它和 watch 的本质区别。


6️⃣ computed vs watch

computed 按需 + 缓存，watch 依赖变化立即回调，scheduler 控制触发时机不同；computed = 派生状态，watch = 副作用

	•	computed 是 惰性求值 + 带缓存 的 effect，它的回调只在 被访问时执行，
并且依赖变化只会 标记 dirty，不会立即触发计算。
	•	watch 是 即时响应副作用 的 effect，
只要依赖 trigger，就会立刻执行回调（可以通过 flush 控制微任务/宏任务）。

换句话说：
	•	computed = 按需计算、可缓存
	•	watch = 显式副作用响应

scheduler 机制在两者都存在，但触发时机不同：
	•	computed 调度只影响 内部缓存是否失效
	•	watch 调度直接影响 回调执行时机

这是 Vue 内部 状态变化驱动 vs 副作用驱动 的根本差异。


7️⃣ 插槽作用域

渲染作用域父组件，数据作用域子组件通过 slot props 显式传递；插槽本质是子执行父函数

8️⃣ provide / inject

默认非响应式；高阶场景：UI 框架 form / tabs 管理上下文，避免 props drilling，可注入 reactive

9️⃣ ref / expose

ref 控制行为合理（弹窗、滚动、表单校验），同步状态反模式；expose 通过 defineExpose 暴露子组件方法

🔟 复合组件 / 组合模式

父 provide 上下文，子 inject 注册实例，高内聚协作，保证结构合法，避免 props drilling

