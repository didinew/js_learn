
⸻

1️⃣ effect / track / trigger 流程

Vue3 的响应式核心是 依赖收集（track） 和 触发更新（trigger），配合 effect 封装响应式函数。

流程图如下（逻辑）：

                 ┌─────────────┐
                 │  调用effect │
                 │ fn()        │
                 └─────┬───────┘
                       │
                       ▼
           ┌─────────────────────────┐
           │  reactive / ref 访问属性 │
           └─────────┬──────────────┘
                     │ track 收集依赖
                     ▼
          ┌─────────────────────────┐
          │  targetMap: target → key → dep(Set) │
          └─────────┬──────────────┘
                    │
                    ▼
       ┌──────────────────────────────┐
       │ 属性变化 trigger(target,key) │
       └─────────┬────────────────────┘
                 │
                 ▼
       ┌──────────────────────────────┐
       │ dep 遍历 effect，执行 scheduler │
       └─────────┬────────────────────┘
                 │
                 ▼
           effect(fn) 或队列异步执行

关键点：
	•	effect(fn)：包裹响应式函数
	•	track(target, key)：收集依赖
	•	trigger(target, key)：触发更新
	•	scheduler：可以控制 effect 执行策略（同步/异步/去重）

⸻

2️⃣ scheduler 为什么避免重复渲染？

scheduler 的作用：控制 effect 执行时机。
	•	默认情况下，effect 立即执行
	•	如果传入 scheduler，effect 不会立即执行，而是交给 scheduler 管理

为什么去重？
	•	同一个响应式属性可能在一轮事件循环内多次变化
	•	如果每次 trigger 都立即执行 effect，会多次渲染
	•	scheduler 可以把多个 trigger 合并到一个队列里
	•	通过 Set 去重，只执行一次渲染

示意：

trigger() x3
 └─> scheduler 收集到 queue
       queue: Set(effect)
       nextTick(() => flushQueue)
           └─> 只执行一次 effect

3️⃣ nextTick 本质是什么？

nextTick(fn) 本质是异步延迟执行函数，保证 DOM 更新完再执行回调。

实现逻辑：



const callbacks = []
let pending = false

function nextTick(cb) {
  callbacks.push(cb)
  if (!pending) {
    pending = true
    Promise.resolve().then(flushCallbacks)  // 微任务
  }
}

function flushCallbacks() {
  pending = false
  const copies = callbacks.slice()
  callbacks.length = 0
  copies.forEach(cb => cb())
}
总结：
	•	nextTick 是微任务队列，保证 effect 执行后 DOM 更新完再操作
	•	Vue3 内部用于 flush scheduler queue

⸻

4️⃣ computed 与 watch 内部如何用 scheduler？

computed
	•	依赖收集依赖属性变化时，会触发 scheduler
	•	默认 computed 是惰性求值：
	•	effect 不会立即执行，而是标记为 dirty
	•	第一次访问 .value 时计算
	•	内部实现使用 scheduler 控制何时重新计算

流程简化：
依赖变化 trigger → computed.effect scheduler → 标记 dirty
访问 .value → dirty? 重新计算 effect → 返回值

watch
	•	watch 内部其实也是 effect 包裹回调
	•	scheduler 默认是异步（flush: ‘post’），用 nextTick 执行
	•	保证回调在 DOM 更新后执行

示意：

reactive 属性变化 → trigger → watch effect scheduler → nextTick 执行回调

⸻

✅ 总结关系表

特性
调用方式
scheduler 使用
nextTick 使用
effect
effect(fn)
可自定义执行策略
可选异步
computed
computed(() =>)
内部 scheduler 控制脏值
访问.value才计算
watch
watch(source, cb)
内部 scheduler 异步刷新
DOM 更新后执行 cb

