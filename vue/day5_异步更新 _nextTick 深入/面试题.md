
⸻

1️⃣ 多次 set 为什么只渲染一次？

本质：Vue3 使用 异步队列 + 微任务调度 来批量更新视图。

流程：
	1.	当你修改响应式数据（reactive / ref）时，会触发依赖收集的 effect。
	2.	effect 的执行会通过 trigger 通知依赖它的副作用函数（如模板渲染函数、computed、watch）。
	3.	如果同一个 effect 多次被触发，Vue 并不会立刻执行它，而是把它放入一个 job queue（更新队列）。
	4.	队列去重：同一个 effect 只会存在队列一次。
	5.	异步刷新：队列会在下一个微任务中 flush，统一执行所有更新。

💡 这样做可以避免重复渲染，提高性能。例如：
state.count++
state.count++
state.count++
// 模板只渲染一次，而不是三次


⸻

2️⃣ scheduler 的作用是什么？

scheduler 是 Vue3 响应式的 调度器机制，它在 effect 的 trigger 和实际执行之间插一层：
	•	默认行为：把 effect 推入异步更新队列（job queue）。
	•	可以自定义 scheduler：让 effect 不立即执行，而是交给你自己调度，比如：
	•	throttle / debounce 控制频率
	•	同步执行（在开发调试时）
	•	在特定时间/条件触发（如动画帧更新）

内部流程简化：
trigger → scheduler(effect) → queue → nextTick flush

💡 scheduler 是 Vue3 异步更新和批处理的核心。

⸻

3️⃣ nextTick 原理是什么？

nextTick 的本质：微任务队列调度器，保证在 DOM 更新完成后再执行回调。
	•	Vue3 异步更新视图是通过 Promise.resolve().then 来实现微任务刷新。
	•	nextTick 就是把回调放在 所有已排队的 effect 执行完后，DOM 更新已经完成。

示意：

state.count++
state.count++
nextTick(() => {
  // 此时 DOM 已经刷新完成
  console.log(document.querySelector('#count').textContent)
})

内部流程简化：
effect queue flush -> DOM 更新 -> nextTick callbacks -> Promise 微任务执行

💡 所以 nextTick 常用于读取更新后的 DOM 或执行依赖最新状态的操作。

⸻

4️⃣ computed 和 watch 内部如何利用异步更新？

computed
	•	computed 是懒执行的 effect（带 getter）。
	•	内部依赖变化时：
	•	不立即执行 getter，而是 标记为 dirty。
	•	下次访问 .value 时才重新计算。
	•	可结合 scheduler：如果在模板中使用，computed 的更新也是异步批量刷新，保证模板渲染只触发一次。

流程：

依赖变化 → trigger → scheduler → mark computed dirty
访问 .value → 重新计算 → 缓存结果

watch
	•	watch 主要用来执行 副作用回调。
	•	内部实现是基于 effect + scheduler：
	•	依赖变化时通过 scheduler 异步执行回调。
	•	默认 flush: 'pre' | 'post' | 'sync'：
	•	'post'（默认） → 在 DOM 更新后触发（类似 nextTick）
	•	'sync' → 立即执行
	•	'pre' → 在 DOM 更新前触发

💡 computed 更偏向 派生值缓存，watch 更偏向 副作用执行，两者都用 scheduler 做异步批量更新，保证性能。

⸻

5️⃣ 关系总结图

reactive/ref set → trigger → scheduler(effect) → job queue → flush (微任务) → DOM 更新
                                                       → nextTick callbacks

computed:
依赖变化 → trigger → scheduler → mark dirty → 下次访问 .value 才重新计算

watch:
依赖变化 → trigger → scheduler → 异步执行 watch 回调（可 flush 配置）