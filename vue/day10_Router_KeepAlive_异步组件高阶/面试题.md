六、🎯 面试输出模板（直接背）


🚀 TabContainer 高阶进阶版（真实业务级）

本轮新增能力（重点）
	1.	✅ 首次才加载（Lazy Mount）
	2.	✅ 组件切换时可控销毁（cleanup）
	3.	✅ 滚动位置记忆
	4.	✅ Suspense Loading / Error
	5.	✅ 面试可讲清楚的设计思路\


  一、能力 1：首次才加载（Lazy Mount）

❌ 问题

默认 component :is 切换时：
	•	所有 Tab 可能都会被解析
	•	首屏不够干净

✅ 解决：记录「已访问 Tab」

const visitedTabs = ref(new Set())

watch(
  activeTab,
  (val) => {
    visitedTabs.value.add(val)
  },
  { immediate: true }
)

const currentComponent = computed(() => {
  const tab = props.tabs.find(t => t.name === activeTab.value)
  if (!tab) return null

  // 首次访问才加载
  if (!visitedTabs.value.has(tab.name)) return null
  return tab.component
})
👉 效果
	•	Tab1 首次显示 → 才 import
	•	Tab2/3 不访问不加载
	•	面试加分：按需挂载 vs 懒加载区别

⸻

二、能力 2：切换时可控销毁（cleanup）

场景
	•	某些 Tab 有 WebSocket / timer
	•	不缓存时需要释放资源

Tab 配置升级
{
  name: 'Tab3',
  label: '监控',
  component: defineAsyncComponent(() => import('./Tab3.vue')),
  keepAlive: false,
  onDeactivate: () => {
    console.log('Tab3 被卸载，清理副作用')
  }
}

TabContainer 内处理

watch(activeTab, (newTab, oldTab) => {
  const old = props.tabs.find(t => t.name === oldTab)
  if (old && old.keepAlive === false && old.onDeactivate) {
    old.onDeactivate()
  }
})
👉 面试高分点

KeepAlive 解决的是组件实例缓存，但副作用清理要业务层自己控制

⸻

三、能力 3：滚动位置记忆（超实用）

场景
	•	列表页切换 Tab
	•	希望回来还能停在原位置

实现（容器级）
const scrollMap = new Map()

watch(activeTab, (newTab, oldTab) => {
  if (oldTab) {
    scrollMap.set(oldTab, window.scrollY)
  }

  nextTick(() => {
    const y = scrollMap.get(newTab) || 0
    window.scrollTo(0, y)
  })
})

👉 效果
	•	切换 Tab 不丢滚动位置
	•	面试官很爱问这种「体验细节」

⸻

四、能力 4：Suspense + Loading + Error

TabContainer 模板升级
<!-- KeepAlive 缓存异步组件 -->
    <Suspense>
        <template #default>
            <KeepAlive :include="cachedTabs">
                <component :is="currentComponent" />
            </KeepAlive>
        </template>
       <template #fallback>
        <slot name="loading">
            <div class="loading">加载中...</div>
        </slot>
        </template>
    </Suspense>
  
  👉 面试高频
	•	Suspense 不是 async/await
	•	是 异步组件渲染控制权

⸻

五、完整 Tabs 配置（最终版）
 const tabs = [
  {
    name: 'form',
    label: '表单',
    component: defineAsyncComponent(() => import('./FormTab.vue')),
    keepAlive: true
  },
  {
    name: 'list',
    label: '列表',
    component: defineAsyncComponent(() => import('./ListTab.vue')),
    keepAlive: true
  },
  {
    name: 'monitor',
    label: '监控',
    component: defineAsyncComponent(() => import('./MonitorTab.vue')),
    keepAlive: false,
    onDeactivate: () => {
      socket.close()
    }
  }
]


⸻

六、🎯 面试输出模板（直接背）

Q1：你们项目 Tab 页是怎么做的？

我们封装了一个通用 TabContainer，
	•	组件按需异步加载
	•	支持 KeepAlive 精准缓存
	•	切换时可选择是否销毁组件
	•	表单和滚动状态都能保持
	•	对性能和体验都做了优化

⸻

Q2：KeepAlive 解决了什么，解决不了什么？

KeepAlive 解决组件实例缓存和状态保持，
但副作用（timer / socket）需要业务层通过 activated / deactivated 或自定义 cleanup 处理。

⸻

Q3：为什么不用 v-if 控制 Tab？

v-if 会反复销毁组件实例，
KeepAlive + 动态 component 才是 SPA 推荐方案。



