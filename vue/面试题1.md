
⸻

🧨 Vue 响应式 & 渲染 · 面试连环问答（满分版）

⸻

题 1：为什么 Vue 用 effect + scheduler 而不是同步 set 触发渲染？

高分答案：

因为 Vue 需要合并多次状态更新，避免重复渲染。
如果同步触发，每次 set 都会重新渲染，状态可能还没稳定，容易造成 DOM 闪烁和性能浪费。
scheduler 会收集依赖，把渲染放入 job queue，再通过微任务统一 flush，这样多次 set 只会渲染一次，保证一致性和性能。

⸻

追问 1：多次 set 是怎么被合并的？

当依赖被 trigger 时，scheduler 会把对应的 effect 放入 job queue，用 Set 去重，保证每个 effect 在同一轮更新中只执行一次。
然后通过微任务 flush queue，批量执行渲染。

⸻

追问 2：为什么放微任务而不是同步或宏任务？

微任务的时机刚好在本轮同步代码执行完成之后，保证状态已经稳定。
	•	同步执行：状态可能不完整，渲染中会读到中间值
	•	宏任务（setTimeout）：渲染延迟到下一轮事件循环，顺序不可控，可能与用户事件错位
放微任务既保证状态完整，又保持渲染顺序可预测，同时批量渲染，性能最佳。

⸻

题 2：nextTick 的本质是什么？

nextTick 并不是单纯等 DOM 渲染，而是等 本轮响应式更新 + patch 完成后再执行回调。
它内部其实就是微任务 flush queue 的封装，保证在状态和 DOM 都稳定后再执行逻辑。

⸻

追问：为什么模板里修改 ref 后马上读 DOM 不准？

因为模板更新是异步的，DOM patch 是在微任务 flush 后才完成。直接读会得到旧 DOM。
nextTick 保证读到的 DOM 是最新状态。

⸻

题 3：computed 为什么是 lazy 的？

computed 内部用 effect + 脏标记（dirty flag）实现懒计算。
它只有在真正访问 value 时才执行函数计算，然后缓存结果，下一次访问就直接返回缓存。
这样避免不必要计算，提高性能。
当依赖变化时，会标记 dirty，下一次访问再重新计算。

⸻

追问：computed 和 watch 有什么区别？

watch 是数据驱动，只关注依赖变化触发回调；
computed 是值驱动，只有被访问才计算，同时有缓存。
watchEffect 则是副作用驱动，每次依赖变化立即执行副作用函数。

⸻

题 4：为什么不推荐 watch 同步 props？

因为会破坏单向数据流，形成双源状态。
如果父组件更新 props，而子组件也通过 watch 改了本地 state，就会出现同步问题。
正确做法：
	•	只展示：直接用 props
	•	需要变更：emit 给父组件
	•	需要加工：用 computed 派生
	•	只初始化一次：const local = ref(props.xxx)（无 watch）

⸻

题 5：状态提升（Lifting State Up）什么时候必须做？

当多个组件需要共享同一状态，或者子组件之间需要相互影响时，状态必须提升到它们共同的父组件或 Store。
临时 UI 状态（hover、loading）不需要提升，核心业务状态（选中项、当前用户）必须提升。

⸻

题 6：Store 和组件状态边界？

Store 管跨组件、跨页面、可恢复的核心业务状态，如用户信息、购物车、WebSocket 数据等。
组件状态只管自身生命周期的 UI 状态，如 modal 是否打开、hover、局部动画。
原则：能局部管理就不要放 Store，必须共享或持久化才放 Store。

⸻

题 7：v-for key 为什么不能用 index？

用 index 会导致 DOM 复用错误，尤其是数组插入/删除时。
只有数组完全不可变或者顺序不会变时，用 index 才安全。
最好用唯一 id 保证渲染正确。

⸻

题 8：shallowReactive / shallowRef 什么时候用？

用在性能敏感的大对象或第三方不可改对象上，只追踪顶层响应，避免递归代理造成性能开销。
适合缓存数据、第三方库对象或大型嵌套结构。

⸻

✅ 总结口语化核心点
	1.	effect + scheduler = 单向 + 批量 + 微任务，性能和一致性
	2.	nextTick = 微任务 flush，保证状态和 DOM 稳定
	3.	computed = lazy + 缓存 + 脏标记
	4.	watch 同步 props = 反模式
	5.	状态提升 = 多组件共享 + 一致性
	6.	Store 管核心业务，组件管局部 UI
	7.	key 唯一，避免 DOM 重排问题
	8.	shallowReactive 控制性能，避免深度递归
