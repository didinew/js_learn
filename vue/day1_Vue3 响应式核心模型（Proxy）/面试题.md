1️⃣ Vue3 响应式三件套是什么？

标准回答：

Vue3 响应式系统由 reactive / effect / track & trigger（或 ref）构成，核心是 Proxy + effect 收集依赖。

更完整说法（面试官最爱）👇

角色
作用
reactive / ref
把数据变成响应式对象（Proxy）
effect
副作用函数，负责依赖收集和重新执行
track / trigger
建立依赖关系 & 触发更新

一句话总结（⚠️ 必背）：

“Proxy 劫持数据，effect 收集依赖，数据变化 trigger effect 重新执行。”

⸻

2️⃣ 为什么 Proxy 比 defineProperty 更适合？

核心答案（不要只说“功能多”）

❌ Object.defineProperty 的问题
	1.	只能劫持已有属性
	•	新增 / 删除属性要额外处理
	2.	深层对象必须递归劫持
	•	初始化性能差
	3.	数组支持极差
	•	push / pop / length 都要 hack

✅ Proxy 的优势
	1.	天然支持新增 / 删除属性
	2.	可以一次性代理整个对象
	3.	完美支持数组
	4.	拦截范围更全
	•	get / set / has / deleteProperty / ownKeys

💡 面试官加分说法：

Proxy 是 运行时拦截，defineProperty 是 初始化时改写属性描述符。

⸻

3️⃣ 为什么说 Vue3 是「惰性响应」？

这是 Vue3 最大的设计升级点之一。

Vue2：立即递归

data() {
  return {
    a: {
      b: {
        c: 1
      }
    }
  }
}

👉 初始化时：
a → b → c 全部 defineProperty

⸻

Vue3：访问时才响应（惰性）
const state = reactive({
  a: {
    b: {
      c: 1
    }
  }
})

state.a.b.c // 访问到这里，才递归代理
关键机制
	•	get 时才把嵌套对象转成 reactive
	•	没用到的属性永远不处理

📌 一句话解释（高分）：

Vue3 只有在 effect 中被访问的数据，才会被 track，才是响应式的。

⸻

4️⃣ effect 在什么时候执行？

标准流程（必会）

effect(() => {
  console.log(state.count)
})


effect 执行 2 个时机
① 注册时立即执行一次

👉 用来：
	•	访问数据
	•	收集依赖（track）

② 依赖的数据变化时再次执行

👉 set → trigger → effect 重新运行

⸻

执行顺序图（面试官最爱）

effect(fn)
  ↓
执行 fn
  ↓
访问响应式数据
  ↓
track(effect)
  ↓
数据变化
  ↓
trigger(effect)
  ↓
重新执行 fn


⸻

🔥 面试 30 秒秒杀总结版

Vue3 响应式基于 Proxy，数据在 effect 中被访问时才收集依赖，
effect 注册时会立即执行一次用于依赖收集，
后续数据变化通过 trigger 精准触发 effect，
整个系统是 惰性、精确、高性能的响应式模型。

