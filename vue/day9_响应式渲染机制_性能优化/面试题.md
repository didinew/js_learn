一、Vue3 响应式 + 渲染完整流程图（必会）

① 总流程（从数据变化到 DOM 更新）

┌──────────────┐
│ reactive/ref │
└──────┬───────┘
       │ Proxy 拦截 get
       ▼
┌──────────────┐
│   track()    │  ← 收集依赖
│ target + key │
└──────┬───────┘
       │
       │ 组件渲染时
       ▼
┌──────────────┐
│   effect()   │  ← 渲染副作用
└──────┬───────┘
       │
       │ 数据 set
       ▼
┌──────────────┐
│  trigger()   │  ← 触发依赖
└──────┬───────┘
       │
       │ 进入调度器
       ▼
┌──────────────┐
│ scheduler    │  ← 去重、批量
└──────┬───────┘
       │ nextTick
       ▼
┌──────────────┐
│ patch diff   │
│ 更新 DOM     │
└──────────────┘

👉 一句话总结（面试秒杀）：

Vue3 是「数据驱动 + effect 副作用 + 调度器批量更新」的响应式系统。

⸻

二、多次 set 为什么只渲染一次？（核心原理）

❌ 错误理解

每次 set 都立刻更新 DOM

✅ 正确原理

set state.count++
↓
trigger()
↓
effect 进入 scheduler
↓
job 放入 Set（去重）
↓
Promise.then()（微任务）
↓
统一执行 effect

关键点 3 连击（面试必答）
	1.	scheduler 不直接执行 effect
	2.	Set 去重（同一个 effect 只进一次）
	3.	微任务统一刷新（nextTick）

	queueJob(job) {
  queue.add(job)       // Set 去重
  if (!isFlushing) {
    isFlushing = true
    Promise.resolve().then(flushJobs)
  }
}

👉 一句话总结：

Vue3 通过「调度器 + Set + 微任务」实现批量更新。

⸻

三、v-for 的 key 到底在干嘛？（99% 人答不全）

没 key 会发生什么？

旧: A B C
新: D A B C

无 key：
A → D（复用错）
B → A
C → B

⸻

有 key 的 diff 流程（简化）

key → vnode
↓
建立 key-index 映射
↓
复用 / 移动 / 新增 / 删除

key 的 3 个真实作用
	1.	精准定位节点
	2.	避免错误复用 DOM
	3.	最大化复用，减少重建

面试必杀句

key 是 diff 算法的“锚点”，
决定 vnode 是否可以被安全复用。

⚠️ index 什么时候能用？
	•	静态列表
	•	永不增删改顺序

⸻

四、shallowReactive / shallowRef 的性能价值

问题本质

不是“是否响应式”，而是“监听多深”

⸻

对比一眼懂

API
特点
场景
reactive
深度响应
表单、业务状态
shallowReactive
只监听第一层
大对象、只关心引用
ref
单值响应
基本类型
shallowRef
只追踪 .value
外部库 / 大数据


⸻

高频性能场景（面试加分）

✅ ECharts / Three.js / 大 JSON

const chart = shallowRef(null)

// 只在整体替换时更新
chart.value = newChartInstance


✅ 后端返回超大对象

const data = shallowReactive({
  list: [] // list 内部不深度追踪
})


👉 一句话总结：

shallow 系列是 Vue3 提供的「性能开关」。

⸻

五、computed / watch / watchEffect 的正确打开方式

三者定位（必须倒背）

API
本质
适合
computed
有缓存的派生值
UI 派生状态
watch
精确监听
副作用
watchEffect
自动收集依赖
简单副作用


⸻

computed 为什么不能有副作用？

computed(() => {
  count.value++ ❌
})


原因：
	•	computed 依赖变化才重新计算
	•	副作用 → 缓存失效 + 状态污染

👉 computed = 纯函数

⸻

watch 的正确姿势

watch(
  () => state.id,
  (id, oldId, onCleanup) => {
    const controller = new AbortController()
    fetchData(id, controller)
    onCleanup(() => controller.abort())
  }
)


👉 副作用 + 清理 = watch

⸻

watchEffect 的使用边界

watchEffect((onCleanup) => {
  const timer = setInterval(...)
  onCleanup(() => clearInterval(timer))
})

⚠️ 不适合复杂依赖
⚠️ 不适合精确控制

⸻

面试官最爱一句话

computed 管派生值
watch 管副作用
watchEffect 管“我也不知道依赖是谁”的情况

⸻

六、终极面试总结（背这一段）

Vue3 响应式基于 Proxy，通过 track / trigger 建立依赖关系，
所有更新进入 scheduler，利用 Set 去重和微任务实现批量更新。
v-for 的 key 决定 vnode 的复用策略，
shallow 系列用于性能敏感场景避免深层追踪，
computed 是纯函数缓存派生值，
watch / watchEffect 专门处理副作用并支持清理。




