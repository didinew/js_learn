
⸻

一、Vue3 响应式 · 连环追问（反杀版）

⸻

Q1：Vue3 为什么用 Proxy，不用 Object.defineProperty？

⭐ 标准回答
	•	Proxy 可以拦截 整个对象
	•	天然支持：
	•	新增 / 删除属性
	•	数组索引、length
	•	性能更好（惰性代理）

🔥 面试官追问 1

什么叫“惰性响应”？

💣 反杀

Vue3 只有在 get 到某个属性时，才对这个属性建立依赖，
没访问过的属性不会 track，避免了 Vue2 的全量递归劫持。

⸻

🔥 追问 2

那嵌套对象什么时候变成响应式？

💣 反杀

在第一次访问这个嵌套对象时，才会对它进行 Proxy 包装，
这是 按需递归，而不是初始化递归。

⸻

Q2：effect 是什么时候执行的？

⭐ 标准回答
	1.	首次执行：组件渲染
	2.	依赖变化：trigger 后调度执行

🔥 追问

effect 为什么不直接执行？

💣 反杀

因为 Vue3 要把 effect 交给 scheduler，
通过队列 + 去重，实现 多次 set → 单次渲染。

⸻

Q3：多次 set 为什么只更新一次 DOM？

⭐ 标准回答
	•	effect 被放入调度队列
	•	使用 Set 去重
	•	微任务统一 flush

🔥 追问

如果在一个 effect 里再次 set 会怎样？

💣 反杀

Vue 内部有 递归更新上限，
同时 effect 会被标记，避免同步死循环。

⸻

Q4：computed 和 effect 有什么本质区别？

⭐ 标准回答
	•	computed 是 lazy effect
	•	有缓存
	•	只有依赖变化才重新计算

🔥 追问

为什么 computed 不能有副作用？

💣 反杀

副作用会破坏缓存的正确性，
computed 的本质是 纯函数 + 依赖缓存，
一旦产生副作用，就无法保证结果一致。

⸻

二、Vue3 diff 算法 · 连环追问（反杀版）

⸻

Q5：Vue3 的 diff 相比 Vue2 有什么改进？

⭐ 标准回答
	•	Vue3 使用 快速 diff
	•	利用 最长递增子序列（LIS）
	•	减少 DOM 移动次数

🔥 追问

什么场景才会用到 LIS？

💣 反杀

当新旧子节点都有 key，且中间节点发生乱序时，
Vue3 才会计算 LIS，最大化节点复用。

⸻

Q6：没有 key 会发生什么？

⭐ 标准回答
	•	采用 就地复用
	•	容易造成状态错乱

🔥 追问

为什么 Vue 不强制要求 key？

💣 反杀

因为在静态列表中，
使用 index 反而能减少 diff 成本，
Vue 把选择权留给开发者。

⸻

Q7：key 为什么不能用 index？

⭐ 标准回答
	•	增删或重排时会错位

🔥 追问

有没有 index 能用的场景？

💣 反杀

列表 永不变更顺序、不增删，
例如纯展示的静态数据。

⸻

Q8：patch 的过程是怎样的？

⭐ 标准回答（简版）
	1.	判断节点类型
	2.	复用或替换
	3.	diff children
	4.	更新 props / text

🔥 追问

为什么文本节点 diff 快？

💣 反杀

因为文本节点只需对比字符串，
不涉及子树递归。

⸻

Q9：Vue3 diff 为什么比 React 快？

⚠️ 注意：别踩坑

⭐ 正确回答

不是谁“更快”，而是 设计目标不同

💣 反杀
	•	Vue：
	•	模板 → 编译期优化
	•	静态提升、patchFlag
	•	React：
	•	运行时 diff
	•	函数式 UI

👉 Vue 在 模板场景更快
👉 React 在 JSX 灵活性更强

⸻

Q10：patchFlag 是干什么的？

⭐ 标准回答
	•	标记哪些节点是动态的
	•	diff 时 跳过静态部分

🔥 追问

patchFlag 是谁生成的？

💣 反杀

由 编译器在编译阶段生成，
运行时只做最少判断。

⸻

三、终极反杀题（面试官压轴）

❓ 为什么 Vue3 的响应式 + diff 是“组合优化”？

💎 满分回答

Vue3 在 响应式层 用 scheduler 批量更新，
在 渲染层 用 patchFlag + 快速 diff 精准更新，
从「数据变化」到「DOM 更新」形成完整的性能闭环。

⸻

四、面试背诵版（30 秒）

Vue3 基于 Proxy 的惰性响应式，
通过 track / trigger 建立依赖，
所有更新进入 scheduler 批量执行。
diff 阶段利用编译期 patchFlag 和运行时 LIS，
最大化复用 DOM，最小化更新成本。