
⸻

⏱️ Vue3 高压追问模拟 · 开始

【第 1 分钟】响应式起手

Q1️⃣
Vue3 中，一个 reactive 对象从创建到第一次渲染，完整流程说一遍，
不准跳步骤。

（我在听：Proxy / track / effect / scheduler）

Vue3 reactive 对象从创建到第一次渲染完整流程

1️⃣ 创建 reactive 对象

const state = reactive({ count: 0 })

	•	Vue3 使用 Proxy 代理整个对象
	•	拦截 get / set / deleteProperty 等操作

⸻

2️⃣ 第一次访问属性 → track 收集依赖
	•	在组件渲染时，模板访问 state.count
	•	Proxy 拦截 get
	•	调用 track(target, key)
	•	将 当前 activeEffect（effect）收集到依赖集合 Dep 中
	•	效果：依赖收集完成，响应式系统知道哪些 effect 依赖了这个属性

⸻

3️⃣ 组件渲染 → effect 执行
	•	effect 是渲染副作用函数，由 Vue 创建
	•	执行 effect → 读取响应式属性 → track 依赖
	•	effect 内部访问的所有 reactive/ref 属性都被收集

⸻

4️⃣ 属性变化 → trigger
	•	当 state.count = 1 执行 set
	•	Proxy 拦截 set
	•	调用 trigger(target, key)
	•	找到所有依赖这个 key 的 effect
	•	并不立即执行，而是进入 调度器 scheduler

⸻

5️⃣ 调度器 scheduler 批量更新
	•	effect 被放入 job 队列 Set，保证 同一个 effect 只存在一次
	•	利用 微任务 (Promise.then)，延迟执行到下一轮事件循环
	•	效果：多次状态变化只执行一次 effect，减少重复渲染

⸻

6️⃣ patch / mount 更新 DOM
	•	effect 执行时触发组件重新渲染
	•	Vue3 虚拟 DOM diff 算法比较新旧 vnode
	•	利用 patchFlag / LIS 等优化
	•	最终把最小差异更新到真实 DOM 上

⸻

🔑 满分面试总结句

Vue3 响应式流程：
Proxy 代理 → track 收集依赖 → effect 渲染 → trigger 通知 → scheduler 批量更新 → patch diff → DOM 更新

⸻

【第 2 分钟】依赖收集深水区

Q2️⃣
track 到底收集的是什么？
是函数？是组件？还是别的东西？

（答错直接判基础不扎实）

track 发生在 effect 执行过程中，
当 effect 内部读取响应式属性触发 get，
才会把 当前 activeEffect 收集到依赖集合中。

⸻

【第 3 分钟】effect 反杀题

Q3️⃣
为什么 Vue3 不能「每次 set 就立刻执行 effect」？
不许只说“性能”。

Vue3 不在 trigger 时立刻执行 effect，
是为了把所有 effect 交给 scheduler 统一调度，
通过 job 队列和 Set 去重，
避免重复执行、避免同步递归更新，
并保证组件更新顺序在微任务阶段一次性完成


⸻

【第 4 分钟】批量更新极限追问

Q4️⃣
在一个 watchEffect 里连续写 5 次 state.count++，
到底发生了几次：
	•	trigger？
	•	effect 执行？
	•	DOM 更新？

给我一个明确数字。

watchEffect(() => {
  state.count++
  state.count++
  state.count++
})

trigger：3 次
effect：1 次
DOM 更新：1 次

🧠 为什么 effect 不是 3 次？

关键机制（这一句是面试分水岭）

trigger 并不会直接执行 effect，
而是把 effect 放进 scheduler 的 job 队列，
同一个 effect 在一个 flush 周期内只会存在一次（Set 去重）。

实际流程

state.count++  → trigger → queueJob(effect)
state.count++  → trigger → queueJob(effect)（已存在，忽略）
state.count++  → trigger → queueJob(effect)（已存在，忽略）
↓
微任务 flush
↓
effect 执行 1 次
↓
DOM patch 1 次



Q5️⃣

如果把上面的 watchEffect 换成 computed：

const double = computed(() => {
  state.count++
  return state.count * 2
})

问题：

1️⃣ 这个 computed 会不会立刻执行？
2️⃣ 会不会死循环？
3️⃣ Vue 为什么“强烈不推荐”这样写？


✅ 精准修正（必须记住）

正确结论

1️⃣ computed 是 lazy 的，不会立刻执行
2️⃣ 一旦被访问，就会进入死循环
3️⃣ 因为副作用破坏了缓存一致性


⸻

🧠 正确执行时序（面试官最爱）


const double = computed(() => {
  state.count++       // 副作用
  return state.count * 2
})

// ❌ 此时不会执行

console.log(double.value)
// ✅ 第一次访问才执行
// → 读取 count
// → 修改 count
// → trigger computed
// → 标记 dirty
// → 再次访问 → 死循环

👉 死循环发生在「访问阶段」，不是声明阶段

⸻

【第 5 分钟】computed 生死线

Q5️⃣
computed 为什么是 lazy 的？
如果我把 computed 改成 eager，会出什么问题？

（这是区分「会用」和「懂原理」的题）

👉 你答。

⸻

【第 6 分钟】diff 算法核心

Q6️⃣
Vue3 的「快速 diff」快在哪里？
不要泛讲 diff，给我“算法层面的原因”。

Q6：Vue3 快速 diff 为什么快？

🔑 核心点 2 个：

1️⃣ 静态节点 + patchFlag 优化
	•	Vue3 编译模板时，标记哪些节点是动态的（patchFlag）
	•	运行时 跳过静态节点，不递归 diff
	•	效果：减少大量不必要的 vnode 比较

2️⃣ 子节点重排用最长递增子序列（LIS）算法
	•	当 key 存在，节点乱序时，计算 LIS
	•	只移动最少节点，最大化复用 DOM
	•	效果：减少移动操作，提升渲染性能

🔑 面试加分话术

Vue3 的 diff 设计是“编译期 + 运行时双重优化”：
patchFlag 跳过静态部分，LIS 最小化移动，
从算法层面保证更新最小化，性能最优。




⸻

【第 7 分钟】key 地狱题

Q7️⃣
以下场景能不能用 index 作为 key？为什么？

[
  { id: 1, name: 'A' },
  { id: 2, name: 'B' }
]

条件：
	•	数据来自接口
	•	不会排序
	•	但可能整体替换

👉 你答。

⸻

⸻

第 8 分钟 · patchFlag 追杀题

Q8：patchFlag 如果不存在，Vue3 能不能工作？它的真实价值是什么？

✅ 满分答案

1️⃣ 没有 patchFlag 也能工作
	•	Vue3 会退回 完全递归 diff
	•	DOM 依然会更新，结果正确，但性能下降

2️⃣ patchFlag 的真实价值
	•	由编译器在 模板编译阶段生成
	•	标记 哪些节点是动态的
	•	diff 时 跳过静态节点 → 减少不必要 vnode 比较
	•	核心目的：最小化运行时计算，提升渲染性能

🔑 面试加分话术

patchFlag = 编译期静态分析 + 运行时动态更新的桥梁
Vue3 的 diff 在 patchFlag 指引下，只处理动态节点，静态节点直接复用。

⸻

第 9 分钟 · shallowRef / 性能题

Q9：什么场景下刻意不用 reactive，而用 shallowRef？

✅ 满分答案

1️⃣ 核心概念
	•	reactive → 深度响应（每一层都 Proxy）
	•	shallowRef → 只响应 .value 的引用变化，不递归

2️⃣ 典型业务场景
	•	第三方库对象，例如 ECharts / Three.js 实例

const chart = shallowRef(null)
chart.value = newChartInstance // 只在整体替换时更新

	•	超大 JSON 数据，只关心第一层引用变化

	const data = shallowReactive({ list: [] }) // list 内部不深度追踪

		•	性能敏感的场景，避免深层 Proxy 消耗和不必要依赖收集

🔑 面试加分话术

shallow 系列是 Vue3 提供的“性能开关”，
用于大对象、外部库或只关心引用变化的场景。

⸻
第 10 分钟 · 终极综合题（性能闭环）

Q10：一句话回答 Vue3 如何把响应式系统和 diff 渲染串成性能闭环？

✅ 满分答案（面试秒杀）

Vue3 通过 Proxy + track/trigger 构建响应式系统，
所有更新进入 scheduler 批量调度，
diff 阶段利用 patchFlag 和最长递增子序列（LIS）优化 DOM 更新，
从数据变化到 DOM 更新形成完整闭环，实现高性能渲染。

🔑 面试加分话术
	•	响应式层 → 数据变化自动通知
	•	渲染层 → patchFlag + LIS 最小化更新
	•	全链路 → 批量、去重、缓存、最小 DOM 操作
