一、HTTP / 网络基础（必问开局）

❓ Q1：GET 和 POST 的本质区别是什么？

（不是“参数位置不同”这种初级答案）

✅ 高分回答：

从 HTTP 语义上看，GET 用于获取资源，POST 用于提交数据以改变服务器状态。
GET 是幂等、可缓存的，请求参数通常在 URL 中；
POST 一般不可缓存，也不保证幂等性，数据放在请求体中。
在浏览器层面，GET 更容易被预加载、缓存、记录在历史中，而 POST 不会。
实际项目中，涉及状态变更或大体量数据，我都会使用 POST。

📌 追问点：幂等性 / 缓存 / 浏览器行为

❓ Q2：你说你了解 HTTPS，那 HTTPS 是怎么保证安全的？

✅ 高分回答：

HTTPS 通过 TLS 实现通信安全，核心流程包括：
1️⃣ 客户端向服务器发起请求并获取证书
2️⃣ 校验证书合法性（CA、域名、有效期）
3️⃣ 使用非对称加密协商对称密钥
4️⃣ 后续通信全部使用对称加密

非对称加密解决密钥交换问题，对称加密保证性能。
同时 HTTPS 能防止中间人攻击和数据篡改。

📌 加分点：非对称 + 对称 各司其职

⸻

❓ Q3：HTTP/2 相比 HTTP/1.1 优化在哪？

✅ 高分回答：

HTTP/2 主要解决了 HTTP/1.1 的性能瓶颈：
	•	多路复用：一个连接并发多个请求，避免队头阻塞
	•	头部压缩：减少重复 Header 传输
	•	二进制分帧：解析更高效

对前端来说，HTTP/2 减少了请求阻塞，降低了对资源合并的依赖。

⸻

二、前后端通信（Axios / Fetch / WebSocket）

❓ Q4：Axios 和 Fetch 有什么本质区别？

✅ 高分回答：

Fetch 是浏览器原生 API，基于 Promise，但：
	•	默认不会 reject 非 2xx 状态
	•	不支持请求 / 响应拦截器

Axios 是基于 XHR 的封装：
	•	自动转换 JSON
	•	支持拦截器、取消请求、超时处理
	•	更适合复杂业务项目

所以在企业项目中我更倾向 Axios。

⸻

❓ Q5：Axios 拦截器你一般用来做什么？

✅ 高分回答：

我通常在请求拦截器中统一注入 Token、处理请求参数；
在响应拦截器中统一处理错误码，比如 401 自动跳转登录、Token 刷新；
这样可以避免业务层重复处理，提高可维护性。

📌 中高级标志：统一错误处理 + Token 刷新

⸻

❓ Q6：什么时候你会用 WebSocket，而不是轮询？

✅ 高分回答：

当业务需要实时性高、服务端主动推送时，我会选择 WebSocket，
比如即时消息、实时状态更新。
相比轮询，WebSocket 减少了无效请求，延迟更低，性能更好。

⸻

三、JavaScript 核心（必杀区）

❓ Q7：说说你对事件循环的理解？

✅ 高分回答：

JavaScript 是单线程的，通过事件循环实现异步。
执行顺序是：同步代码 → 微任务队列 → 宏任务队列。
Promise.then 属于微任务，setTimeout 属于宏任务。
浏览器每一轮事件循环都会优先清空微任务。

📌 面试官判定点：微任务优先级

⸻

❓ Q8：为什么 async/await 看起来像同步？

✅ 高分回答：

async/await 本质是 Promise 的语法糖。
await 会让出执行权，后续代码被包装成微任务，
所以写法像同步，但执行机制仍然是异步。

⸻

四、HTML / CSS（容易被低估的杀分区）

❓ Q9：为什么 transform 比 top/left 动画性能好？

✅ 高分回答：

transform 只触发合成层，不会引起回流和重绘；
top/left 会触发布局计算和重绘，开销更大；
所以高性能动画应优先使用 transform 和 opacity。

⸻

❓ Q10：BFC 是什么？解决过什么问题？

✅ 高分回答：

BFC 是独立的布局环境。
我常用它解决：
	•	父元素高度塌陷
	•	margin 重叠
	•	两栏自适应布局
通过 overflow: hidden 或 display: flow-root 触发。

⸻

五、Vue 全家桶（核心区）

❓ Q11：Vue 为什么要用虚拟 DOM？

✅ 高分回答：

虚拟 DOM 本质是 JS 对真实 DOM 的抽象，
通过 diff 算法减少不必要的 DOM 操作，
提高复杂 UI 更新的可维护性和性能稳定性。

⸻

❓ Q12：Vuex 解决了什么问题？不用行不行？

✅ 高分回答：

Vuex 解决的是跨组件共享状态和状态可预测性问题。
小项目可以不用，但在复杂业务中，Vuex 能避免 props 层层传递，
并让状态变更更可追踪、可维护。


① Axios 为什么要封装？

✅ 标准回答

为了统一处理 Token、错误码、请求配置，避免业务代码重复。

🔪 追问 1：不封装会怎样？

错误处理分散，维护成本高，修改一处规则要改多处。

🔪 追问 2：封装一般放哪？

单独 request 模块，结合拦截器，不和业务代码耦合。

🔥 反杀补充（主动说）

实际项目中我还会加请求取消、防重复提交和 Token 自动刷新机制。

⸻

② computed 和 watch 有什么本质区别？

✅ 标准回答

computed 用于派生状态，有缓存；watch 用于副作用。

🔪 追问 1：缓存是怎么来的？

computed 只在依赖变化时重新计算。

🔪 追问 2：watch 能替代 computed 吗？

不适合，watch 是命令式，不利于状态表达。

🔥 反杀补充

只要是“由状态算出来的值”，我都会优先用 computed。

⸻

③ Vue 为什么要用虚拟 DOM？

✅ 标准回答

为了减少真实 DOM 操作，提高复杂更新的稳定性。

🔪 追问 1：一定更快吗？

不一定，简单场景直接操作 DOM 更快。

🔪 追问 2：那为什么还用？

因为可维护性和性能可预测性更重要。

🔥 反杀补充

框架的优势不是极限性能，而是在复杂场景下依然稳定。

⸻

④ ref 为什么要 .value？

✅ 标准回答

ref 返回的是响应式对象，.value 才是真实值。

🔪 追问 1：为什么不直接返回值？

无法保持引用关系，响应式会失效。

🔪 追问 2：reactive 为什么不用？

reactive 是对象级别，ref 适合基础类型。

🔥 反杀补充

Vue3 用 ref / reactive 区分场景，降低心智负担。

⸻

⑤ 为什么 key 不能用 index？

✅ 标准回答

index 不是稳定标识，容易导致 DOM 错误复用。

🔪 追问 1：什么时候用 index 没问题？

静态列表、无增删排序的场景。

🔪 追问 2：错在哪？

diff 会错误复用节点，组件状态错乱。

🔥 反杀补充

key 本质是帮助 diff 快速定位节点。

⸻

⑥ Promise.then 为什么是微任务？

✅ 标准回答

为了保证状态在当前任务结束后立即同步。

🔪 追问 1：为什么不放宏任务？

宏任务会延迟到下一轮，破坏链式语义。

🔪 追问 2：和 MutationObserver 有关系吗？

都属于微任务队列。

🔥 反杀补充

微任务设计是为了更强的一致性。

⸻

⑦ WebSocket 和轮询怎么选？

✅ 标准回答

实时性高、服务端推送场景用 WebSocket。

🔪 追问 1：WebSocket 有什么问题？

连接维护成本高、需心跳与重连。

🔪 追问 2：一定比轮询好？

低频更新不划算。

🔥 反杀补充

实际会结合业务频率选择。

⸻

⑧ 为什么 transform 动画性能好？

✅ 标准回答

不触发回流，只走合成层。

🔪 追问 1：top/left 会怎样？

触发布局计算和重绘。

🔪 追问 2：GPU 一定更快？

过多图层也会有开销。

🔥 反杀补充

性能优化永远是权衡，不是盲用。

⸻

⑨ Vuex mutation 为什么同步？

✅ 标准回答

保证状态变更可追踪。

🔪 追问 1：异步写 mutation 会怎样？

状态变化不可预测，调试困难。

🔪 追问 2：那异步放哪？

action。

🔥 反杀补充

Vuex 的核心是可维护性，不是限制。

🌊 WebSocket / 实时系统 · 深水区追问卡

⸻

① WebSocket 和 HTTP 轮询 / SSE 的本质区别？

✅ 标准回答

WebSocket 是全双工长连接，支持服务端主动推送；
轮询是客户端定期请求；
SSE 是单向推送，基于 HTTP。

🔪 追问 1：那为什么不用 SSE？

SSE 只支持服务端 → 客户端；
不适合双向交互场景。

🔪 追问 2：WebSocket 一定更快吗？

不一定，低频更新时轮询更简单、成本更低。

🔥 反杀补充

选型关键是消息频率、方向和连接成本。

⸻

② WebSocket 连接是怎么建立的？

✅ 标准回答

先通过 HTTP 握手；
使用 Upgrade: websocket 升级协议；
成功后切换为 TCP 长连接。

🔪 追问 1：为什么还要 HTTP？

复用现有端口和代理体系。

🔪 追问 2：HTTPS 下怎么处理？

实际是 WSS，仍基于 TLS。

🔥 反杀补充

所以 WebSocket 不是“新协议栈”，而是升级协议。

⸻

③ WebSocket 心跳机制是干嘛的？

✅ 标准回答

防止中间设备关闭空闲连接；
同时检测连接是否可用。

🔪 追问 1：浏览器不是会自动维护吗？

网络断开、NAT 超时浏览器感知不到。

🔪 追问 2：一般多久一次？

30～60 秒，视业务而定。

🔥 反杀补充

心跳失败通常触发重连策略。

⸻

④ WebSocket 如何实现断线重连？

✅ 标准回答

监听 close / error；
使用指数退避重连；
避免频繁重连雪崩。

🔪 追问 1：为什么不用固定时间？

容易放大服务器压力。

🔪 追问 2：页面刷新怎么办？

需恢复订阅状态。

🔥 反杀补充

重连不仅是“连上”，还要状态恢复。

⸻

⑤ WebSocket 如何保证消息不丢？

✅ 标准回答

客户端 ACK 确认；
服务端重发机制；
必要时持久化消息。

🔪 追问 1：那实时性会下降吗？

是的，需要权衡。

🔪 追问 2：一定要可靠投递吗？

非核心消息可容忍丢失。

🔥 反杀补充

实时系统 = 一致性 vs 实时性的取舍。

⸻

⑥ 如何避免消息风暴？

✅ 标准回答

服务端合并推送；
客户端节流 / 防抖；
按业务优先级分发。

🔪 追问 1：前端能做什么？

合并 UI 更新，requestAnimationFrame。

🔪 追问 2：一定要全量更新吗？

不，增量更新更优。

🔥 反杀补充

消息多≠渲染多。

⸻

⑦ WebSocket 如何做权限控制？

✅ 标准回答

握手时携带 Token；
服务端校验并绑定连接身份。

🔪 追问 1：Token 放 URL 安全吗？

不安全，易泄露。

🔪 追问 2：更好的方式？

Cookie + WSS 或 Header。

🔥 反杀补充

权限控制不只在连接阶段。

⸻

⑧ 多 Tab WebSocket 怎么处理？

✅ 标准回答

共用连接或主 Tab 维护；
使用 BroadcastChannel 同步。

🔪 追问 1：每个 Tab 一个连接行吗？

浪费资源。

🔪 追问 2：断开怎么办？

选主策略切换。

🔥 反杀补充

多 Tab 是实时系统的隐藏杀点。

⸻

⑨ WebSocket 和前端状态管理怎么结合？

✅ 标准回答

WebSocket 只负责通信；
状态仍交给 Vuex / Pinia。

🔪 追问 1：直接改组件 state 行不行？

会失控，不可追踪。

🔪 追问 2：消息太多怎么办？

按类型分发，核心优先。

🔥 反杀补充

实时系统 ≠ 直接 setState。

⸻

⑩ 终极深水题（杀伤力极强）

WebSocket 崩溃最常见原因是什么？

✅ 标准回答

心跳和重连策略不当；
消息处理与渲染耦合；
缺乏限流与降级。

🔥 反杀总结
真正难的不是连上，而是稳定运行。