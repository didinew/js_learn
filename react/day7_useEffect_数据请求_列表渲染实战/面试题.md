1️⃣ useEffect 的依赖数组是做什么的？

useEffect 的依赖数组（第二个参数 deps）控制 副作用函数的执行时机。

useEffect(() => {
  console.log('副作用执行');
}, [count]);

	•	空数组 []
	•	副作用只在 组件挂载时执行一次，相当于 componentDidMount。
	•	有依赖 [dep1, dep2]
	•	副作用 仅在依赖发生变化时执行。
	•	不写依赖数组
	•	副作用 每次渲染都会执行（注意性能和副作用问题）。

🔹 本质上，依赖数组告诉 React：我这个 effect 依赖哪些状态或 props，只有它们变了才重新执行 effect。

⸻

2️⃣ 清理函数什么时候执行？

useEffect 可以返回一个函数作为 清理函数：

useEffect(() => {
  const id = setInterval(() => console.log('tick'), 1000);

  return () => {
    clearInterval(id); // 清理
  };
}, []);

清理函数的执行时机：
	1.	组件卸载时
	•	类似 componentWillUnmount。
	2.	依赖变化前（非空数组情况）
	•	如果依赖 [dep1, dep2] 改变，React 会先执行旧 effect 的清理函数，再执行新的 effect。

⚠️ 这就是为什么可以用它来清理定时器、取消订阅、取消 API 请求等。

⸻

3️⃣ 为什么 API 请求不能直接写在函数体里？

不要在组件的 主体函数 里直接写异步请求，例如：

function MyComponent() {
  fetch('/api/data').then(res => ...); // ❌ 每次渲染都会触发
  return <div>...</div>;
}

原因：
	1.	每次渲染都会执行
	•	React 可能因状态更新多次渲染，导致重复请求。
	2.	副作用逻辑应与渲染解耦
	•	函数组件本质是纯函数（同样的 props 和 state 应该返回同样的 JSX），请求数据属于副作用。
	3.	解决方案
	•	使用 useEffect：

	useEffect(() => {
  fetch('/api/data').then(res => ...);
}, []); // 只请求一次


🔹 总结：函数体里只做 渲染计算，副作用逻辑（API、订阅、DOM 操作）放 useEffect。

⸻

4️⃣ 条件渲染 + 列表渲染如何组合使用？

场景：有一个数组，部分元素可能需要根据条件显示或隐藏。

const todos = [
  { id: 1, text: '吃饭', done: true },
  { id: 2, text: '睡觉', done: false },
];

组合写法：


<ul>
  {todos.map(todo => 
    todo.done ? <li key={todo.id}>{todo.text}</li> : null
  )}
</ul>

或者用短路逻辑：

<ul>
  {todos.map(todo => (
    todo.done && <li key={todo.id}>{todo.text}</li>
  ))}
</ul>

✅ 注意点：
	•	key 必须唯一，不能用索引（尤其是列表可能增删时）。
	•	条件渲染返回 null 时 React 不会渲染任何 DOM。
	•	可以先 过滤数组 再渲染，代码更清晰：

	todos
  .filter(todo => todo.done)
  .map(todo => <li key={todo.id}>{todo.text}</li>)


🔹 核心原则：先处理数据，再映射成 JSX，保证渲染逻辑清晰、性能友好。

⸻
