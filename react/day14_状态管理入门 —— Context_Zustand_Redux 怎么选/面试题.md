1️⃣ 什么状态适合做全局？什么不适合？

✅ 适合全局状态的特征

一句话总结：“跨页面 / 跨组件、长期存在、业务级别的状态”

常见例子：
	•	用户信息（user / token / role / 权限）
	•	登录态、主题色、语言（theme / i18n）
	•	全局配置、feature flag
	•	多页面共用的筛选条件
	•	WebSocket 推送的共享数据

👉 判断口诀：

多个不相关组件要用 + 不希望层层 props 传

⸻

❌ 不适合全局的状态

一句话总结：“组件私有、生命周期短、强 UI 绑定”

典型反例：
	•	表单输入值
	•	弹窗开关（只在当前页面用）
	•	hover / focus 状态
	•	下拉是否展开
	•	临时计算结果

❗ 面试官加分点：

状态一旦放全局，就失去了组件隔离性，调试和回收都更困难

⸻

2️⃣ Context 的性能问题是什么？

核心结论

Context 的问题不是慢，而是“更新粒度太粗”

具体问题
	•	Context value 发生变化
	•	所有消费该 Context 的组件都会重新渲染
	•	即使组件只用了 value 里的一个字段

  const value = { user, theme }

<UserContext.Provider value={value}>

只要 user 或 theme 变：
👉 所有 useContext(UserContext) 的组件都 rerender

⸻

为什么难优化？
	•	useContext 没有 selector
	•	无法像 Redux / Zustand 那样只订阅一部分
	•	必须：
	•	拆 Context
	•	或手动 memo value

⸻

面试官想听的一句话

Context 更适合低频、静态、配置类数据，而不是高频业务状态

⸻

3️⃣ 为什么很多项目选 Zustand？

这题是送分题，但要答“为什么它刚好踩在甜点区”。


⸻

Zustand 的核心优势

✅ 1. 精细订阅（性能好）

const count = useStore(state => state.count)

	•	只在 count 变时重渲染
	•	天然避免 Context 全量更新问题

⸻

✅ 2. 心智负担小
	•	不需要 Provider
	•	不用 reducer / action / dispatch
	•	就是一个 可响应的 JS store

👉 面试官会点头的评价：

“Zustand 更接近 useState 的使用体验”

⸻

✅ 3. 支持非 React 场景
	•	WebSocket
	•	定时器
	•	事件回调
	•	service 层

  store.getState().setData()


⸻

✅ 4. 规模适中，刚刚好
	•	比 Context 强
	•	比 Redux 轻
	•	非常适合：
	•	中后台
	•	实时数据
	•	多模块共享状态

⸻

4️⃣ Redux 现在还用吗？

标准答案

用，但用的是 Redux Toolkit，不是老 Redux

⸻

Redux 现在的定位

✅ 适合场景
	•	超大型项目
	•	状态流转复杂
	•	需要：
	•	严格规范
	•	可预测性
	•	中间件生态（日志、埋点、权限、回放）

⸻

❌ 不适合
	•	中小项目
	•	快速迭代
	•	状态简单但被迫写一堆模板代码

⸻

面试官加分总结

	•	小项目：Context / Zustand
	•	中大型项目：Zustand / RTK
	•	超复杂业务：RTK + 规范化流程

⸻

🎯 一句话终极总结（背下来）

状态越靠近业务核心、生命周期越长、影响范围越广，就越适合全局；
状态越贴近 UI、变化越频繁、作用范围越小，就越不适合。
