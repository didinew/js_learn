1️⃣ JSX 是什么？

✅ 一句话版

JSX 是 JavaScript 的语法糖，本质是 React.createElement 的调用。

⸻

🔍 原理版

const el = <div className="box">Hello</div>

编译后（Babel）：

const el = React.createElement(
  'div',
  { className: 'box' },
  'Hello'
)

👉 JSX ≠ HTML
👉 JSX 不会直接生成 DOM
👉 它生成的是 React Element（描述 UI 的普通 JS 对象）

⸻

🧠 关键点总结
	•	JSX 是：
	•	✅ JS 表达式
	•	✅ 可组合
	•	❌ 不是模板
	•	JSX 的作用：
	•	声明 UI 结构
	•	提升可读性
	•	让 UI = f(state) 更直观

⸻

🎯 面试官追问反杀

❓「不用 JSX 可以写 React 吗？」

✅ 可以，JSX 只是语法糖，不是必须

⸻

2️⃣ 组件的本质是什么？

✅ 一句话版

组件本质是：根据 props 和 state 返回 React Element 的函数。

⸻

🔍 原理版

function Button(props) {
  return <button>{props.text}</button>
}

等价于：

function Button(props) {
  return React.createElement(
    'button',
    null,
    props.text
  )
}

👉 组件 ≠ DOM
👉 组件 ≠ class / function 本身
👉 组件 = UI 的计算规则

⸻

🧠 深层理解

组件是：
	•	一个 纯渲染函数
	•	输入：props + state
	•	输出：UI 描述（React Element）

这也是为什么：
	•	props 必须只读
	•	render 必须是纯函数
	•	相同输入 ⇒ 相同 UI

⸻

🎯 面试官追问反杀

❓「那 Hooks 是什么？」

✅ Hooks 是让函数组件拥有状态和副作用的机制，而不是组件本身

⸻

3️⃣ React 是如何更新 UI 的？

✅ 一句话版

React 通过状态变化 → 重新执行组件 → diff 新旧虚拟 DOM → 最小化更新真实 DOM

⸻

🔍 完整流程（重点）

① 状态变化

setState / setCount

② 组件重新执行

Component(props, state)

👉 得到 新的 React Element Tree

③ Virtual DOM Diff
	•	对比新旧 element
	•	找出最小差异
	•	生成更新计划（patch）

④ 提交更新
	•	批量更新真实 DOM
	•	合并多次 state 更新
	•	避免频繁重排 / 重绘

⸻

🧠 React 的核心思想

“不要直接操作 DOM，让 UI 由状态决定”

公式：

UI = f(state)
❓「React 为什么不直接操作 DOM？」

✅ 因为：
	•	DOM 操作昂贵
	•	状态变化频繁
	•	React 可以：
	•	批量更新
	•	中断渲染（Concurrent）
	•	跨平台（Web / Native）

⸻

🧠 三题合并终极总结（面试 30 秒版）

JSX 是 createElement 的语法糖
组件本质是根据 props 和 state 返回 UI 描述的函数
React 在状态变化时重新执行组件，通过虚拟 DOM diff，最小成本更新真实 DOM


