Q1️⃣：Vue 3 中，为什么多次 state.count++ 只会触发一次组件渲染？

多次状态变更会多次 trigger，但 effect 不会立即执行，而是被 scheduler 收集进 job 队列，通过 Set 去重，最终在同一轮事件循环中只执行一次渲染。


Q2️⃣：React 中，为什么在同一个事件里多次 setState 也只会触发一次渲染？

在同一个事件循环中，多次 setState 不会立刻触发渲染，而是先被放入更新队列。
React 会在批处理（batching）阶段合并这些更新，由调度器统一计算最终 state，只触发一次 render，从而减少不必要的重复渲染。


Q3️⃣（对比题，面试官最爱）

Vue 和 React 都能“多次更新只渲染一次”，
那它们在“触发更新的时机”上有什么本质区别？

Vue 是响应式驱动的框架，在运行时通过 track / trigger 精确收集和触发依赖，
只有真正依赖该状态的组件或计算才会更新。

React 不是响应式系统，它通过 setState 标记组件为 dirty，
重新执行整个函数组件，在 render 阶段通过对比 Virtual DOM 决定最小更新。

Vue 是“数据驱动更新组件”，React 是“组件更新推导 UI”

Q4️⃣（Vue × React 进阶对位）

Vue 有 computed，React 为什么没有？
那 React 是如何“等价解决 computed 这个问题”的？

Vue 是响应式系统，computed 本质是基于依赖追踪的派生值缓存，
只有依赖变化时才会重新计算。

React 函数组件每次渲染都会重新执行函数体，
因此通过 useMemo 缓存计算结果、通过 useCallback 缓存函数引用，
以“显式依赖数组”的方式控制重算时机，达到与 computed 等价的效果。

一句话封神总结：

Vue 的 computed 是自动依赖收集，
React 的 useMemo 是显式依赖声明。

Q5️⃣（Vue × React 性能陷阱）

在 React 中滥用 useMemo / useCallback，
反而可能让性能更差，这是为什么？

React 函数组件每次渲染都会重新执行，
useMemo / useCallback 本身也有依赖比较成本和闭包创建成本。

当计算本身很轻，或依赖频繁变化时，
缓存的收益会小于维护缓存的成本，反而让性能变差，代码也更复杂。

类似于 Vue 中滥用 watchEffect，
会导致不必要的副作用执行、依赖追踪膨胀，甚至死循环或内存问题。

一句话封神总结：

缓存不是免费午餐，只有“重计算 + 稳定依赖”才值得缓存

Q6️⃣（Vue × React 哲学级问题）

Vue 的“自动依赖收集” 和 React 的“显式依赖数组”，
你更倾向哪一种？为什么？

这两种设计没有绝对优劣，更取决于项目规模和团队结构。

Vue 的自动依赖收集降低了心智负担，
框架帮开发者兜底，更适合中小型项目或经验层次不齐的团队，
能快速交付、减少误用成本。

React 的显式依赖数组把控制权交给开发者，
学习成本更高，但在大型项目和复杂状态场景下，
更有利于可预测性和长期维护，前提是团队有足够的规范和经验。

一句话封神总结（强烈建议背）：

Vue 用机制换简单，React 用显式换可控

🧨 架构 / 终面问题 ①（必问）

Q1️⃣：

“项目变大以后，你是如何控制 Vue / React 项目的复杂度的？”
① 先给结论（先稳住）

项目复杂度不是靠某一个技术解决，而是架构分层 + 约束规则共同控制。

⸻

② 架构层面（核心）

我会把项目拆成 表现层、状态层、业务层、基础能力层，
UI 组件只负责展示，业务逻辑下沉到组合函数 / hooks，
状态集中管理，避免跨组件隐式依赖。

（Vue / React 都适用）

⸻

③ 代码层面（工程经验）
	•	组件只做一件事（高内聚）
	•	禁止跨模块直接引用状态
	•	复杂逻辑强制抽成 useXxx
	•	状态变更有入口（Pinia / Redux）

⸻

④ 工程约束（拉开差距）
	•	ESLint + 规则约束
	•	目录结构强约定
	•	Code Review 必须过

⸻

⑤ 收尾（体现负责人意识）

如果没有这些约束，项目规模一旦扩大，
复杂度是指数级上升的。

⸻

🧨 架构 / 终面问题 ②（杀伤力更大）

Q2️⃣：

“你是如何设计一个‘可长期维护’的组件体系的？”

⚠️ 这是区分「高级前端 vs 架构型前端」的问题
✅ 终面满分答题结构

① 先定原则（很重要）

我区分 基础组件 / 业务组件 / 页面组件，
不同层级有不同的设计标准。

⸻

② 基础组件（最严格）
	•	无业务逻辑
	•	props / emit 明确
	•	不依赖 store / 路由
	•	高复用、低耦合

⸻

③ 业务组件（最容易烂）
	•	只服务一个业务域
	•	禁止跨业务复用
	•	逻辑可抽，但 UI 不强行复用

⸻

④ 页面组件（可以脏）
	•	只做组合
	•	不写复杂逻辑
	•	生命周期集中处理

⸻

⑤ 演进意识（终面杀招）

一开始不追求“完美抽象”，
而是在复用出现 第二次、第三次 时再上升抽象。
🎯 再送你一个「终面保险回答」

如果面试官突然问：

“你觉得你现在最大的不足是什么？”

标准高分答法：

我现在在持续补架构和系统设计，
技术实现我比较有信心，
但我希望在更大规模项目的决策层面做得更好。

🔥【终面 · Round 2】深挖追问（架构级）

Q2️⃣

你刚才提到 「低 / 中 / 高频状态分层管理」，
那我追问你一个真实场景：

一个复杂列表页：
	•	顶部筛选条件
	•	中间分页列表
	•	每一项都有 hover、展开、选中状态

👉 哪些状态放组件内？哪些进全局？为什么？

	•	局部状态（组件内部）
	•	顶部筛选条件、中间分页列表当前页、简单交互状态
	•	通过 props / emit 或父子组件状态传递管理
	•	原因：仅限局部使用，无需全局管理，降低复杂度
	•	跨组件或共享状态（全局 / 模块化管理）
	•	每一项 hover、展开、选中状态，尤其是选中状态
	•	如果需要跨组件操作、或者提交给后端
	•	放入模块化状态管理（Vue：Pinia / React：Redux）
	•	原因：保证数据一致性、避免状态漂移
	•	总结原则

局部状态归组件，跨组件/共享状态归全局，
同时遵循“低耦合、高内聚、可追踪”的设计。

Q3️⃣

假设这个列表页访问量很大，用户频繁操作 hover / 展开 / 勾选，
你会如何优化性能，保证页面不卡顿？

Q3 满分答案（高并发列表性能优化）

1️⃣ 渲染优化
	•	列表使用虚拟列表 / windowing，只渲染当前可视区域 DOM
	•	减少节点数量，降低渲染和 diff 开销

2️⃣ 事件优化
	•	hover / 展开 / 勾选等高频事件使用节流或防抖
	•	避免短时间内频繁触发组件更新或状态修改

3️⃣ 渲染调度优化
	•	对大规模 DOM 更新使用 requestAnimationFrame 或 Vue3/React 批量更新
	•	保证页面渲染平滑，不阻塞主线程

4️⃣ 可选加分点（面试官喜欢）
	•	使用 computed / useMemo / useCallback 缓存计算和函数，避免重复渲染
	•	分层状态管理（局部 vs 全局），尽量减少状态漂移触发全局渲染




