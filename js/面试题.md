一、HTTP / 网络基础（必问开局）

❓ Q1：GET 和 POST 的本质区别是什么？

（不是“参数位置不同”这种初级答案）

✅ 高分回答：

从 HTTP 语义上看，GET 用于获取资源，POST 用于提交数据以改变服务器状态。
GET 是幂等、可缓存的，请求参数通常在 URL 中；
POST 一般不可缓存，也不保证幂等性，数据放在请求体中。
在浏览器层面，GET 更容易被预加载、缓存、记录在历史中，而 POST 不会。
实际项目中，涉及状态变更或大体量数据，我都会使用 POST。

📌 追问点：幂等性 / 缓存 / 浏览器行为

❓ Q2：你说你了解 HTTPS，那 HTTPS 是怎么保证安全的？

✅ 高分回答：

HTTPS 通过 TLS 实现通信安全，核心流程包括：
1️⃣ 客户端向服务器发起请求并获取证书
2️⃣ 校验证书合法性（CA、域名、有效期）
3️⃣ 使用非对称加密协商对称密钥
4️⃣ 后续通信全部使用对称加密

非对称加密解决密钥交换问题，对称加密保证性能。
同时 HTTPS 能防止中间人攻击和数据篡改。

📌 加分点：非对称 + 对称 各司其职

⸻

❓ Q3：HTTP/2 相比 HTTP/1.1 优化在哪？

✅ 高分回答：

HTTP/2 主要解决了 HTTP/1.1 的性能瓶颈：
	•	多路复用：一个连接并发多个请求，避免队头阻塞
	•	头部压缩：减少重复 Header 传输
	•	二进制分帧：解析更高效

对前端来说，HTTP/2 减少了请求阻塞，降低了对资源合并的依赖。

⸻

二、前后端通信（Axios / Fetch / WebSocket）

❓ Q4：Axios 和 Fetch 有什么本质区别？

✅ 高分回答：

Fetch 是浏览器原生 API，基于 Promise，但：
	•	默认不会 reject 非 2xx 状态
	•	不支持请求 / 响应拦截器

Axios 是基于 XHR 的封装：
	•	自动转换 JSON
	•	支持拦截器、取消请求、超时处理
	•	更适合复杂业务项目

所以在企业项目中我更倾向 Axios。

⸻

❓ Q5：Axios 拦截器你一般用来做什么？

✅ 高分回答：

我通常在请求拦截器中统一注入 Token、处理请求参数；
在响应拦截器中统一处理错误码，比如 401 自动跳转登录、Token 刷新；
这样可以避免业务层重复处理，提高可维护性。

📌 中高级标志：统一错误处理 + Token 刷新

⸻

❓ Q6：什么时候你会用 WebSocket，而不是轮询？

✅ 高分回答：

当业务需要实时性高、服务端主动推送时，我会选择 WebSocket，
比如即时消息、实时状态更新。
相比轮询，WebSocket 减少了无效请求，延迟更低，性能更好。

⸻

三、JavaScript 核心（必杀区）

❓ Q7：说说你对事件循环的理解？

✅ 高分回答：

JavaScript 是单线程的，通过事件循环实现异步。
执行顺序是：同步代码 → 微任务队列 → 宏任务队列。
Promise.then 属于微任务，setTimeout 属于宏任务。
浏览器每一轮事件循环都会优先清空微任务。

📌 面试官判定点：微任务优先级

⸻

❓ Q8：为什么 async/await 看起来像同步？

✅ 高分回答：

async/await 本质是 Promise 的语法糖。
await 会让出执行权，后续代码被包装成微任务，
所以写法像同步，但执行机制仍然是异步。

⸻

四、HTML / CSS（容易被低估的杀分区）

❓ Q9：为什么 transform 比 top/left 动画性能好？

✅ 高分回答：

transform 只触发合成层，不会引起回流和重绘；
top/left 会触发布局计算和重绘，开销更大；
所以高性能动画应优先使用 transform 和 opacity。

⸻

❓ Q10：BFC 是什么？解决过什么问题？

✅ 高分回答：

BFC 是独立的布局环境。
我常用它解决：
	•	父元素高度塌陷
	•	margin 重叠
	•	两栏自适应布局
通过 overflow: hidden 或 display: flow-root 触发。

⸻

五、Vue 全家桶（核心区）

❓ Q11：Vue 为什么要用虚拟 DOM？

✅ 高分回答：

虚拟 DOM 本质是 JS 对真实 DOM 的抽象，
通过 diff 算法减少不必要的 DOM 操作，
提高复杂 UI 更新的可维护性和性能稳定性。

⸻

❓ Q12：Vuex 解决了什么问题？不用行不行？

✅ 高分回答：

Vuex 解决的是跨组件共享状态和状态可预测性问题。
小项目可以不用，但在复杂业务中，Vuex 能避免 props 层层传递，
并让状态变更更可追踪、可维护。


① Axios 为什么要封装？

✅ 标准回答

为了统一处理 Token、错误码、请求配置，避免业务代码重复。

🔪 追问 1：不封装会怎样？

错误处理分散，维护成本高，修改一处规则要改多处。

🔪 追问 2：封装一般放哪？

单独 request 模块，结合拦截器，不和业务代码耦合。

🔥 反杀补充（主动说）

实际项目中我还会加请求取消、防重复提交和 Token 自动刷新机制。

⸻

② computed 和 watch 有什么本质区别？

✅ 标准回答

computed 用于派生状态，有缓存；watch 用于副作用。

🔪 追问 1：缓存是怎么来的？

computed 只在依赖变化时重新计算。

🔪 追问 2：watch 能替代 computed 吗？

不适合，watch 是命令式，不利于状态表达。

🔥 反杀补充

只要是“由状态算出来的值”，我都会优先用 computed。

⸻

③ Vue 为什么要用虚拟 DOM？

✅ 标准回答

为了减少真实 DOM 操作，提高复杂更新的稳定性。

🔪 追问 1：一定更快吗？

不一定，简单场景直接操作 DOM 更快。

🔪 追问 2：那为什么还用？

因为可维护性和性能可预测性更重要。

🔥 反杀补充

框架的优势不是极限性能，而是在复杂场景下依然稳定。

⸻

④ ref 为什么要 .value？

✅ 标准回答

ref 返回的是响应式对象，.value 才是真实值。

🔪 追问 1：为什么不直接返回值？

无法保持引用关系，响应式会失效。

🔪 追问 2：reactive 为什么不用？

reactive 是对象级别，ref 适合基础类型。

🔥 反杀补充

Vue3 用 ref / reactive 区分场景，降低心智负担。

⸻

⑤ 为什么 key 不能用 index？

✅ 标准回答

index 不是稳定标识，容易导致 DOM 错误复用。

🔪 追问 1：什么时候用 index 没问题？

静态列表、无增删排序的场景。

🔪 追问 2：错在哪？

diff 会错误复用节点，组件状态错乱。

🔥 反杀补充

key 本质是帮助 diff 快速定位节点。

⸻

⑥ Promise.then 为什么是微任务？

✅ 标准回答

为了保证状态在当前任务结束后立即同步。

🔪 追问 1：为什么不放宏任务？

宏任务会延迟到下一轮，破坏链式语义。

🔪 追问 2：和 MutationObserver 有关系吗？

都属于微任务队列。

🔥 反杀补充

微任务设计是为了更强的一致性。

⸻

⑦ WebSocket 和轮询怎么选？

✅ 标准回答

实时性高、服务端推送场景用 WebSocket。

🔪 追问 1：WebSocket 有什么问题？

连接维护成本高、需心跳与重连。

🔪 追问 2：一定比轮询好？

低频更新不划算。

🔥 反杀补充

实际会结合业务频率选择。

⸻

⑧ 为什么 transform 动画性能好？

✅ 标准回答

不触发回流，只走合成层。

🔪 追问 1：top/left 会怎样？

触发布局计算和重绘。

🔪 追问 2：GPU 一定更快？

过多图层也会有开销。

🔥 反杀补充

性能优化永远是权衡，不是盲用。

⸻

⑨ Vuex mutation 为什么同步？

✅ 标准回答

保证状态变更可追踪。

🔪 追问 1：异步写 mutation 会怎样？

状态变化不可预测，调试困难。

🔪 追问 2：那异步放哪？

action。

🔥 反杀补充

Vuex 的核心是可维护性，不是限制。

🌊 WebSocket / 实时系统 · 深水区追问卡

⸻

① WebSocket 和 HTTP 轮询 / SSE 的本质区别？

✅ 标准回答

WebSocket 是全双工长连接，支持服务端主动推送；
轮询是客户端定期请求；
SSE 是单向推送，基于 HTTP。

🔪 追问 1：那为什么不用 SSE？

SSE 只支持服务端 → 客户端；
不适合双向交互场景。

🔪 追问 2：WebSocket 一定更快吗？

不一定，低频更新时轮询更简单、成本更低。

🔥 反杀补充

选型关键是消息频率、方向和连接成本。

⸻

② WebSocket 连接是怎么建立的？

✅ 标准回答

先通过 HTTP 握手；
使用 Upgrade: websocket 升级协议；
成功后切换为 TCP 长连接。

🔪 追问 1：为什么还要 HTTP？

复用现有端口和代理体系。

🔪 追问 2：HTTPS 下怎么处理？

实际是 WSS，仍基于 TLS。

🔥 反杀补充

所以 WebSocket 不是“新协议栈”，而是升级协议。

⸻

③ WebSocket 心跳机制是干嘛的？

✅ 标准回答

防止中间设备关闭空闲连接；
同时检测连接是否可用。

🔪 追问 1：浏览器不是会自动维护吗？

网络断开、NAT 超时浏览器感知不到。

🔪 追问 2：一般多久一次？

30～60 秒，视业务而定。

🔥 反杀补充

心跳失败通常触发重连策略。

⸻

④ WebSocket 如何实现断线重连？

✅ 标准回答

监听 close / error；
使用指数退避重连；
避免频繁重连雪崩。

🔪 追问 1：为什么不用固定时间？

容易放大服务器压力。

🔪 追问 2：页面刷新怎么办？

需恢复订阅状态。

🔥 反杀补充

重连不仅是“连上”，还要状态恢复。

⸻

⑤ WebSocket 如何保证消息不丢？

✅ 标准回答

客户端 ACK 确认；
服务端重发机制；
必要时持久化消息。

🔪 追问 1：那实时性会下降吗？

是的，需要权衡。

🔪 追问 2：一定要可靠投递吗？

非核心消息可容忍丢失。

🔥 反杀补充

实时系统 = 一致性 vs 实时性的取舍。

⸻

⑥ 如何避免消息风暴？

✅ 标准回答

服务端合并推送；
客户端节流 / 防抖；
按业务优先级分发。

🔪 追问 1：前端能做什么？

合并 UI 更新，requestAnimationFrame。

🔪 追问 2：一定要全量更新吗？

不，增量更新更优。

🔥 反杀补充

消息多≠渲染多。

⸻

⑦ WebSocket 如何做权限控制？

✅ 标准回答

握手时携带 Token；
服务端校验并绑定连接身份。

🔪 追问 1：Token 放 URL 安全吗？

不安全，易泄露。

🔪 追问 2：更好的方式？

Cookie + WSS 或 Header。

🔥 反杀补充

权限控制不只在连接阶段。

⸻

⑧ 多 Tab WebSocket 怎么处理？

✅ 标准回答

共用连接或主 Tab 维护；
使用 BroadcastChannel 同步。

🔪 追问 1：每个 Tab 一个连接行吗？

浪费资源。

🔪 追问 2：断开怎么办？

选主策略切换。

🔥 反杀补充

多 Tab 是实时系统的隐藏杀点。

⸻

⑨ WebSocket 和前端状态管理怎么结合？

✅ 标准回答

WebSocket 只负责通信；
状态仍交给 Vuex / Pinia。

🔪 追问 1：直接改组件 state 行不行？

会失控，不可追踪。

🔪 追问 2：消息太多怎么办？

按类型分发，核心优先。

🔥 反杀补充

实时系统 ≠ 直接 setState。

⸻

⑩ 终极深水题（杀伤力极强）

WebSocket 崩溃最常见原因是什么？

✅ 标准回答

心跳和重连策略不当；
消息处理与渲染耦合；
缺乏限流与降级。

🔥 反杀总结
真正难的不是连上，而是稳定运行。

必杀题 ①（JS 异步 · 分水岭）

题目
Promise.resolve()
  .then(() => {
    console.log(1)
    return Promise.resolve(2)
  })
  .then(console.log)

Promise.resolve()
  .then(() => {
    console.log(3)
  })

  1
3
2
📌 执行过程拆解（面试版）

1️⃣ 同步代码执行完后，开始执行 微任务队列

2️⃣ 第一个 Promise.resolve().then(...)
	•	执行 then 回调 → 输出 1
	•	返回 Promise.resolve(2)
	•	第二个 then 不会立刻执行，而是等这个 Promise resolve

3️⃣ 第二个 Promise.resolve().then(...)
	•	输出 3

4️⃣ 前面返回的 Promise resolve
	•	触发 .then(console.log)
	•	输出 2

⸻

🔍 面试官追问 1

为什么 return Promise.resolve(2) 会“多等一轮”？

✅ 回答要点
	•	then 的返回值如果是 Promise
	•	外层 Promise 会 “状态跟随”
	•	后续 then 会被 重新放入微任务队列

👉 本质是 Promise flatten（扁平化）

⸻

🔍 面试官追问 2

如果改成这样，输出是什么？

.then(() => {
  console.log(1)
  return 2
})
1
2
3
👉 因为 return 普通值会被 Promise.resolve 包裹，直接进入同一轮微任务

⸻

🌟 加分话术（面试官一听就懂你很深）

Promise 的 then 本质不是回调注册，而是创建一个新的 Promise。
如果返回值是 Promise，新 Promise 会等待它 settle，
如果是普通值，则立即 resolve，这就是 then 链条节奏差异的根本原因。

⸻

🧠 再加一刀（杀招）

async/await 其实只是 Promise.then 的语法糖，
await 后面的代码等价于 then 中的回调，只是写法更接近同步。

必杀题 ②（JS 底层 · 历史级分水岭）

题目

为什么 typeof null === 'object'？
✅ 标准回答（能过）

在 JavaScript 早期实现中，值的类型是通过“低位标记”来区分的：
	•	对象：000
	•	整数：001
	•	浮点数：010
	•	字符串：100
	•	boolean：110
	•	null 的值是全 0

由于 null 的二进制表示和 object 的类型标记冲突，
typeof null 被错误地识别为 object。

🔍 面试官追问 1

那为什么不修？

✅ 回答要点
	•	typeof null === 'object' 已经被大量代码依赖
	•	修改会导致 Web 生态级别的破坏
	•	TC39 明确决定 保持兼容

👉 JS 宁愿“脏”，也要 不破坏已有代码

🔍 面试官追问 2

那现在怎么正确判断 null？
val === null

❌ 不要用 typeof
❌ 不要用 Object.prototype.toString

⸻

🌟 加分话术（面试官喜欢）

typeof 的设计目标是运行时快速判断基础类型，
而不是一个精确的类型系统，所以它本身就存在边界问题。

🧠 延伸一刀（非常加分）

这也是为什么后续 ES 引入了：

	•	Array.isArray
	•	Object.is
	•	Symbol
而不是继续扩展 typeof


🔥 面试官隐藏杀招

那 typeof function(){} === 'function' 是例外吗？

⭐ 高级回答

是的，function 本质仍然是 object，
但 JS 引擎对 callable 对象做了特殊标记，
typeof 单独返回 function，是为了开发者体验。

必杀题 ③（异步并发 · 工程能力分水岭）

题目

实现 Promise 并发控制（限流）
100 个异步任务，最多同时执行 5 个


✅ 标准回答（思路先行）

核心思想只有一句话：

维护一个任务队列 + 当前并发数，完成一个就补一个


⸻

✅ 标准实现（面试可写）
function promisePool(tasks, limit) {
  let i = 0
  let running = 0
  const results = []

  return new Promise((resolve, reject) => {
    function run() {
      if (i === tasks.length && running === 0) {
        resolve(results)
        return
      }

      while (running < limit && i < tasks.length) {
        const cur = i++
        running++

        Promise.resolve(tasks[cur]())
          .then(res => {
            results[cur] = res
          })
          .catch(reject)
          .finally(() => {
            running--
            run()
          })
      }
    }

    run()
  })
}


⸻

🔍 面试官追问 1

为什么要用 while，而不是 if？

✅ 回答
	•	while 可以在 同一轮事件循环中补满并发
	•	if 只会补一个，并发爬升慢

👉 这是性能细节，不是语法问题


🔍 面试官追问 2

如果其中一个任务 reject 了怎么办？

标准策略（任选说明）
	1.	立即中断（如请求链依赖）
	2.	收集错误继续跑
	3.	重试机制（指数退避）

🌟 加分
.catch(err => {
  results[cur] = err
})
这个实现有什么问题？

高级回答
	•	没有超时控制
	•	没有取消能力
	•	大量任务可能造成 微任务堆积

🌟 加分话术（工程向）

实际业务中我会结合：

	•	AbortController
	•	请求优先级
	•	动态调整 limit
比如首屏 limit = 2，后台 limit = 8

🧠 再补一刀（秒杀 90% 候选人）

Promise 并发控制本质是 信号量（Semaphore）模型，
JS 只是用事件循环模拟了这个并发调度。
必杀题 ④（Vue3 原理 · 框架级分水岭）

题目

Vue3 为什么比 Vue2 快？
✅ 标准回答（一句话版）

Vue3 的快，核心不是 Proxy，
而是 编译期做了更多事，运行时做了更少事。

① 编译优化（最核心）

✔️ 静态提升（Static Hoisting）
	•	静态节点只创建一次
	•	不参与后续 Diff
    const _hoisted_1 = /*#__PURE__*/ createElementVNode(...)

⸻

✔️ PatchFlag（精准更新）
<div :class="cls">{{ msg }}</div>
→ 编译后知道：
	•	只有 class 和 text 可能变
	•	Diff 时 跳过无关属性

⸻

✔️ Block Tree（局部 Diff）
	•	动态节点才进 Block
	•	Diff 只在 Block 内进行

👉 Diff 范围直接缩小


⸻

② 响应式系统升级（不是唯一原因）
Vue2
Vue3
Object.defineProperty
Proxy
初始化递归
按需代理
无法监听新增属性
天然支持

③ 运行时更轻
	•	更少 watcher
	•	更少依赖收集
	•	Tree-shaking 友好

Block Tree 是什么？解决了什么问题？

高级回答

Block Tree 把模板拆分成「静态区 + 动态区」，
更新时只遍历动态节点，避免全树 Diff。

⸻

🔍 面试官追问 2

Vue3 的 Diff 和 Vue2 有本质区别吗？

正确回答

算法思想类似，
但 Vue3 通过编译信息 减少了 Diff 的输入规模。

👉 算法没变，数据变少了

⸻

🌟 加分话术（非常重要）

Vue3 的性能提升，本质是：
把运行时的不确定性，前移到编译期解决

这句话 非常值钱。
🧠 再补一刀（大厂喜欢）

这也是为什么 Vue3 更依赖模板编译，
而 JSX 写法在性能确定性上反而更弱。

必杀题 ⑤（Diff 算法 · 设计哲学题）

题目

为什么 Vue / React 的 Diff 只做「同层比较」？
为什么不做跨层 Diff？

✅ 标准回答（核心版）

因为 DOM 操作成本远高于 JS 计算成本，
同层 Diff 可以在 可控复杂度内，最大限度减少 DOM 操作。

✅ 深度拆解（面试官想听）

① 跨层 Diff 的问题

假设允许跨层移动节点：
	•	需要在整棵树中搜索可复用节点
	•	时间复杂度接近 O(n³)
	•	即使 JS 算出来了，DOM 移动成本依然极高

👉 算得起，动不起


⸻

② 同层 Diff 的优势
	•	节点结构假设稳定
	•	只对兄弟节点做最小变更
	•	可用 key + 双端指针优化

👉 用 结构约定 换 性能确定性

那跨层移动节点怎么办？

正确回答

框架通过 开发者约定 解决：

	•	跨层移动 ≈ 删除 + 新建
	•	使用 key 明确节点身份
	•	结构变化交给业务控制

那 React Fiber 不是支持中断吗？能跨层吗？

高级回答

Fiber 优化的是 调度（可中断），
不是 Diff 规则，
Diff 依然是同层的。


⸻

🌟 加分话术（非常高级）

Diff 算法本质不是“找最优解”，
而是 在工程可接受的成本下，找到足够好的解。

必杀题 ⑥（浏览器原理 · 架构分水岭）

题目

浏览器是多进程还是多线程？分别有哪些？

✅ 标准回答（一句话）

浏览器是多进程的，每个进程内部是多线程的。

⸻

✅ 关键进程（至少说 4 个）

① 浏览器主进程（Browser Process）
	•	管理窗口
	•	地址栏、书签
	•	网络请求调度

⸻

② 渲染进程（Renderer Process）【最重要】
	•	HTML / CSS / JS 执行
	•	Layout / Paint
	•	每个 tab 基本一个

👉 安全隔离的关键

⸻

③ GPU 进程
	•	图形加速
	•	3D / Canvas / CSS 动画

⸻

④ 网络进程
	•	HTTP / HTTPS
	•	WebSocket
	•	缓存

⸻

（加分）
	•	插件进程
	•	扩展进程

JS 为什么是单线程？

标准回答

为了避免 DOM 操作冲突。
如果 JS 多线程同时修改 DOM，
会引入复杂的锁机制，性能和一致性都会变差。

⸻

🔍 面试官追问 2

那 Web Worker 是什么？

高级回答

Web Worker 是 运行在独立线程的 JS 环境，
不能直接操作 DOM，
通过 postMessage 通信。

⸻

🔍 面试官追问 3

那浏览器如何做到“不卡”？

正确回答
	•	JS 执行在渲染进程的主线程
	•	UI 渲染和 JS 交替执行
	•	超时任务被拆分（事件循环）

⸻

🌟 加分话术（很重要）

JS 是单线程的，但浏览器不是。
卡顿本质不是 JS 慢，而是 主线程被占用。

⸻

🧠 再补一刀（大厂加分）

这也是为什么：

	•	长计算要丢到 Worker
	•	动画用 CSS / GPU
	•	计算要分片
必杀题 ⑦（浏览器渲染 · 性能核心）

题目

什么是重排（Reflow）和重绘（Repaint）？有什么区别？

	•	重排（Reflow）：
DOM 几何结构发生变化（位置、尺寸），
浏览器需要重新计算布局树
	•	重绘（Repaint）：
元素样式变化但不影响布局（颜色、背景），
只重新绘制像素

👉 重排一定引发重绘，重绘不一定重排

⸻

✅ 哪些操作会触发 Reflow（必背）

📐 几何相关
	•	width / height
	•	padding / margin
	•	top / left
	•	display

📄 DOM 结构
	•	添加 / 删除节点
	•	改变节点层级

📊 查询布局信息（隐藏杀招）
offsetWidth
clientHeight
getComputedStyle()
👉 读也可能触发重排
为什么“读属性”也会触发重排？

高级回答

浏览器会 延迟布局计算，
当你读取布局信息时，
它必须先强制 flush 布局队列，
以保证数据准确。

⸻

🔍 面试官追问 2

如何避免频繁重排？

标准策略
	•	批量 DOM 操作（DocumentFragment）
	•	读写分离
	•	使用 class 切换样式
	•	display: none 后操作

🌟 加分话术（杀招）

transform / opacity 只触发 合成层更新，
不参与 Layout 和 Paint，
所以动画更流畅。

⸻

🧠 再补一刀（工程级）

性能优化的核心不是“少写 DOM”，
必杀题 ⑧（浏览器 · 网络 · 渲染全链路）

题目

从输入 URL 到页面渲染完成，浏览器经历了哪些关键过程？

⸻

✅ 标准回答（清晰版）

① URL 解析
	•	补全协议
	•	判断是搜索还是地址

⸻

② DNS 解析
	•	浏览器缓存
	•	系统缓存
	•	本地 hosts
	•	DNS 服务器

⸻

③ 建立连接
	•	TCP 三次握手
	•	HTTPS：TLS 握手（证书校验、密钥协商）

⸻

④ 发送 HTTP 请求
	•	请求行 / 头 / 体

⸻

⑤ 服务器处理 & 返回响应
	•	状态码
	•	响应头
	•	HTML 数据流

⸻

⑥ 浏览器解析 HTML（重点）
	•	构建 DOM Tree
	•	解析 CSS → CSSOM
	•	DOM + CSSOM → Render Tree

⚠️ CSS 会阻塞渲染

⸻

⑦ 布局（Layout） & 绘制（Paint）
	•	计算位置
	•	绘制像素

⸻

⑧ 合成（Composite）
	•	GPU 合成图层
	•	显示到屏幕

⸻

🔍 面试官追问 1

JS 会阻塞页面渲染吗？

正确回答
	•	默认会
	•	因为 JS 可能操作 DOM / CSSOM
	•	可通过：
	•	defer
	•	async
	•	放底部

⸻

🔍 面试官追问 2

CSS 为什么会阻塞渲染？

高级回答

浏览器必须拿到完整 CSSOM，
才能确定元素最终样式，
否则会出现样式闪烁。

⸻

🔍 面试官追问 3

DOMContentLoaded 和 load 区别？

标准回答

事件
触发时机
DOMContentLoaded
DOM 构建完成
load
所有资源加载完成

🌟 加分话术（非常重要）

首屏性能优化，本质就是：
让关键路径更短，让阻塞更少

⸻

🧠 再补一刀（架构级）

HTTP/2 多路复用、资源优先级、预加载，
都是在优化这条关键渲染路径。

必杀题 ⑨（前端性能优化 · 工程实战）

题目

你做过哪些前端性能优化？

✅ 标准回答（分层结构化）

一、网络层优化

✔️ 减少请求数量
	•	资源合并
	•	HTTP/2 多路复用

✔️ 减少请求体积
	•	gzip / brotli
	•	图片 WebP / AVIF

✔️ 缓存策略
	•	强缓存（Cache-Control）
	•	协商缓存（ETag）

⸻

二、渲染层优化（核心）

✔️ 关键渲染路径优化
	•	CSS 放 head
	•	JS defer / async
	•	关键 CSS 内联

✔️ 避免重排
	•	transform / opacity
	•	批量 DOM 操作

✔️ 虚拟列表
	•	只渲染可视区

⸻

三、JS 执行层优化

✔️ 减少主线程阻塞
	•	Web Worker
	•	分片计算（requestIdleCallback）

✔️ 节流 / 防抖
	•	高频事件
	•	WebSocket 推送

⸻

🔍 面试官追问 1

你是怎么定位性能问题的？

标准回答
	•	Chrome DevTools
	•	Network
	•	Performance
	•	Lighthouse
	•	打点监控
	•	FP / FCP / LCP
	•	TTI

⸻

🔍 面试官追问 2

你优化后效果如何？

高级回答（一定要量化）

首屏 FCP 从 2.8s 降到 1.4s，
列表滚动帧率从 30fps 提升到接近 60fps。

⸻

🌟 加分话术（非常重要）

性能优化不是“全都做”，
而是 先找到瓶颈，再针对性优化。

⸻

🧠 再补一刀（大厂级）

实际项目中，我更关注 用户感知性能，
而不仅是技术指标。


⸻

必杀题 ⑩（前端不卡死 · 高并发场景）

题目

前端如何防止页面“卡死”？
高频 WebSocket 推送、复杂图表、大量计算怎么办？

⸻

❌ 常见错误回答
	•	用 setTimeout
	•	防抖 / 节流
	•	lazy load

👉 太浅，没体现工程能力

⸻

✅ 标准回答（分层思路）

① 主线程隔离

✔️ Web Worker
	•	把 计算密集型逻辑移到 Worker
	•	不阻塞 UI 渲染
	•	Worker → postMessage 传回结果

✔️ requestIdleCallback / setTimeout 分片计算
	•	大数组 / 大量循环拆成小块
	•	每次只占用少量主线程时间

⸻

② 渲染优化

✔️ 虚拟列表 / 虚拟滚动
	•	只渲染可视区 DOM
	•	大量节点也不卡

✔️ 图表优化
	•	Canvas / WebGL
	•	避免频繁更新 DOM
	•	动画使用 GPU（transform / opacity）

⸻

③ 数据节流与优先级

✔️ WebSocket 推送
	•	防抖 / 节流 / 合并更新
	•	核心业务优先，非核心可以丢弃或延迟

✔️ 请求分片
	•	大量请求按重要级别分批更新 UI
	•	控制并发数（Semaphore / Promise Pool）

⸻

④ 性能监控
	•	FPS / JS 执行时间
	•	首屏渲染时间
	•	避免微小卡顿累积成体验差

⸻

🔍 面试官追问 1

为什么 Worker 不能直接操作 DOM？

✅ 回答
	•	Worker 在独立线程
	•	没有 DOM 访问权限
	•	UI 数据通过 postMessage 传回主线程处理

⸻

🔍 面试官追问 2

图表频繁更新怎么办？

高级回答
	•	Canvas 层 vs DOM 层分离
	•	动画使用 requestAnimationFrame
	•	只更新变化部分（增量渲染）

⸻

🌟 加分话术（杀招）

页面不卡不是减少数据量，而是 控制主线程占用 + 合理分发任务 + 渲染优化。
高并发场景核心是 “谁先执行、谁延迟、谁丢弃”。

⸻

🧠 再补一刀（大厂加分）

实际项目中，我会结合：

	•	数据分层（核心业务 vs 辅助业务）
	•	并发控制
	•	虚拟化渲染
	•	Worker 分片计算

这样即使 WebSocket 100ms 推送一次，也不卡。

6️⃣ Vue Router

题目：路由守卫有哪些类型？
答案：
	•	全局守卫：beforeEach / afterEach
	•	路由独享守卫：beforeEnter
	•	组件内守卫：beforeRouteEnter / beforeRouteUpdate / beforeRouteLeave
追问：权限控制如何实现？
	•	利用 meta 字段 + 路由守卫判断 token / 角色。


7️⃣ Vue 性能优化

题目：Vue 页面渲染慢，你会怎么优化？
答案：
	1.	使用 v-if/v-show 控制渲染
	2.	computed 缓存复杂计算
	3.	异步组件 / 路由懒加载
	4.	v-once、key 优化列表
	5.	使用虚拟列表处理长列表
8️⃣ 事件修饰符

题目：Vue 事件修饰符 .stop, .prevent 的作用？
答案：
	•	.stop 阻止事件冒泡
	•	.prevent 阻止默认事件
追问：.self 有什么用？
	•	只在事件源本身触发，不包括子元素。

1️⃣6️⃣ Vuex / Pinia

题目：Vuex 与 Pinia 区别？
答案：
	•	Pinia API 更简单，支持模块自动拆分
	•	Vuex 需要 mutations/action
	•	Pinia 支持 TS 类型推导


⸻

4️⃣ 组件通信

题目：Vue 组件通信方式？

标准答案：
	1.	父传子：props
	2.	子传父：$emit
	3.	非父子：EventBus / mitt / Pinia / Vuex
	4.	插槽：父控子渲染

追问：Pinia 优势？
	•	TS 类型推导
	•	状态集中管理
	•	响应式可跨组件使用

加分话术：
	•	提到 store.subscribe, store.watch 实现副作用
    