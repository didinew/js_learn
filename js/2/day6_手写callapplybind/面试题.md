---
① 基础默认绑定
```js
function foo() {
  console.log(this)
```
}
foo()

✅ 答案
- 非严格：window
- 严格：undefined

📌 原因：普通函数默认绑定
---
② 对象方法调用

```js
const obj = {
```
  name: 'obj',
  foo() {
```js
    console.log(this.name)
```
  }
}
obj.foo()

✅ 答案
- 输出：obj

📌 原因：隐式绑定
---
③ 隐式丢失

```js
const obj = {
```
  name: 'obj',
  foo() {
```js
    console.log(this.name)
```
  }
}
```js
const f = obj.foo
```
f()
✅ 答案

undefined / window.name

📌 原因：脱离对象调用
---
④ 隐式丢失（回调地狱）

```js
const obj = {
```
  name: 'obj',
  foo() {
    setTimeout(function () {
```js
      console.log(this.name)
```
    }, 0)
  }
}
obj.foo()

✅ 答案
undefined

📌 原因：回调函数默认绑定
---
⑤ 箭头函数修复 this

```js
const obj = {
```
  name: 'obj',
  foo() {
    setTimeout(() => {
```js
      console.log(this.name)
```
    }, 0)
  }
}
obj.foo()

✅ 答案
- 输出：obj

📌 原因：箭头函数继承外层 this
---
⑥ 显式绑定 call
```js
function foo() {
  console.log(this.name)
```
}
foo.call({ name: 'call' })
✅ 答案
call

📌 原因：call 方法指定 this 指向
---
⑦ bind 永久绑定

```js
function foo() {
  console.log(this.name)
```
}
```js
const bar = foo.bind({ name: 'bind' })
```
bar.call({ name: 'call' })
✅ 答案
bind
📌 原因：bind 最高优先级（仅次于 new）
---
⑧ new vs bind

```js
function Foo() {
```
  this.name = 'foo'
}
```js
const Bar = Foo.bind({ name: 'bind' })
const b = new Bar()
console.log(b.name)
```
✅ 答案
foo

📌 原因：new 绑定优先级最高
---
⑨ 箭头函数 + bind

```js
const foo = () => {
  console.log(this.name)
```
}
foo.bind({ name: 'bind' })()
✅ 答案
undefined
📌 原因：箭头函数 this 不可绑定
---
⑩ 多层对象调用

```js
const obj = {
```
  name: 'obj',
  foo() {
```js
    return {
```
      name: 'inner',
      bar() {
```js
        console.log(this.name)
```
      }
    }
  }
}
obj.foo().bar()
✅ 答案
inner
---
⑪ 多层对象 + 箭头函数

```js
const obj = {
```
  name: 'obj',
  foo() {
```js
    return {
```
      name: 'inner',
      bar: () => {
```js
        console.log(this.name)
```
      }
    }
  }
}
obj.foo().bar()
✅ 答案
obj
📌 原因：箭头函数继承 foo 的 this
---
⑫ 原型方法 this

```js
function Person(name) {
```
  this.name = name
}
Person.prototype.say = function () {
```js
  console.log(this.name)
```
}

```js
const p = new Person('DiDi')
```
p.say()
✅ 答案
DiDi
📌 原因：this 指向调用者实例
---
⑬ 原型方法丢失 this
```js
const say = p.say
```
say()
✅ 答案
undefined
📌 原因：脱离实例调用
---
⑭ class 中的 this
```js
class A {
  constructor() {
```
    this.name = 'A'
  }
  foo() {
```js
    console.log(this.name)
```
  }
}
```js
const a = new A()
const f = a.foo
```
f()
✅ 答案
undefined
📌 原因：class 默认严格模式
---
⑮ 终极混合题（面试官最爱）
```js
var name = 'global'

const obj = {
```
  name: 'obj',
  foo() {
```js
    console.log(this.name)
    return () => {
      console.log(this.name)
```
    }
  }
}

```js
const fn = obj.foo()
```
fn()
✅ 答案
obj
obj
📌 原因：
- foo：隐式绑定 → obj
- 返回箭头函数 → 继承 foo 的 this

🧠 终极判断口诀（背）

先看有没有 new
再看 bind / call / apply
再看是不是对象调用
最后默认绑定
箭头函数直接看定义处
