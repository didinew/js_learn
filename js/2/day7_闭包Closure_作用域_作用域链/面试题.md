第 1 题：闭包最基础（送分但常错）

function foo() {
  let a = 1
  return function () {
    console.log(a++)
  }
}

const f = foo()
f()
f()
✅ 输出
1
2
🧠 原因
	•	a 被内部函数引用
	•	foo 执行完，作用域不销毁
	•	a 状态被保留

🎯 追问

如果 const a = 1 呢？

💥 答：

报错，因为不能修改 const

⸻

第 2 题：多个闭包是否共享？

function foo() {
  let a = 1
  return function () {
    console.log(++a)
  }
}

const f1 = foo()
const f2 = foo()

f1()
f1()
f2()
✅ 输出
2
3
2
🧠 原因
	•	每次调用 foo() 都创建独立作用域
	•	闭包不共享变量，除非共享同一个函数实例

⸻

第 3 题：for + var 经典绞肉机

for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0)
}

✅ 输出
3
3
3
🧠 原因
	•	var 没有块级作用域
	•	所有回调共享同一个 i

🎯 追问

为什么不是 0 1 2？

💥 答：

因为回调执行时，循环已经结束，i 变成了 3


⸻

第 4 题：for + let（反杀面试官）

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0)
}

✅ 输出
0
1
2
🧠 原因
	•	每轮循环创建独立块级作用域
	•	本质是“自动闭包隔离”

⸻

第 5 题：立即执行函数 IIFE
for (var i = 0; i < 3; i++) {
  (function (i) {
    setTimeout(() => console.log(i), 0)
  })(i)
}
✅ 输出
0
1
2
🧠 原因
	•	IIFE 为每次 i 创建独立作用域


⸻

第 6 题：闭包 + this（高频绞杀）
var x = 10

function foo() {
  var x = 20
  return function () {
    console.log(this.x)
  }
}

const f = foo()
f()

✅ 输出
10
🧠 原因
	•	闭包不影响 this
	•	普通函数调用 → this 指向 window

🎯 追问

怎么输出 20？

💥 答：
return () => console.log(x)

⸻

第 7 题：闭包 + 参数陷阱
function foo(a) {
  return function (a) {
    console.log(a)
  }
}

foo(1)(2)

✅ 输出
2
🧠 原因
	•	内部参数 a 覆盖外部 a
	•	不是闭包访问外部变量

📌 这题的坑：它根本不是闭包题

⸻

第 8 题：闭包缓存（函数记忆）
function create() {
  let cache = {}
  return function (key) {
    if (cache[key]) return cache[key]
    return (cache[key] = key * 2)
  }
}

const fn = create()
console.log(fn(2))
console.log(fn(2))

✅ 输出
4
4
🧠 原因
	•	cache 被闭包保存
	•	第二次直接命中缓存

🎯 追问

缺点？

💥 答：

cache 无限制增长，可能内存泄漏

⸻

第 9 题：变量提升 + 闭包地雷
function test() {
  console.log(a)
  var a = 1
}
test()
✅ 输出

undefined

🧠 原因

var a
console.log(a)
a = 1

⸻

第 🔟 题：let TDZ + 闭包终结技

let a = 10

function test() {
  console.log(a)
  let a = 20
}
test()

❌ 结果
ReferenceError
🧠 原因
	•	let 存在 暂时性死区（TDZ）
	•	在声明前访问直接报错

⸻

💀 面试官最狠三连追问

❓ 闭包为什么不会被 GC？

因为仍被引用，引用计数不为 0

⸻

❓ 闭包一定会导致内存泄漏吗？

不一定，只有不合理持有大对象/DOM 才会

⸻

❓ let 循环是不是闭包？

本质是块级作用域隔离，行为等价于闭包

