---
# this（看这一块就够）

一句话定生死

this 永远只看“怎么调用”，跟定义位置无关
---
this 绑定优先级（必背）

new  >  显式 bind/apply/call  >  隐式 obj.fn()  >  默认（window / undefined）
---
this 判定口诀

场景
this
普通函数
window / undefined
obj.fn()
obj
new Fn()
新实例
箭头函数
外层 this
---
## 闭包（3 句话）

闭包是什么

函数 + 它能访问的外层作用域
---
什么时候形成闭包
- 函数嵌套
- 引用外层变量
- 内层函数被拿到外面执行
---
闭包本质
- 延长变量生命周期
- GC 不回收被引用变量
---
闭包风险
- 内存占用
- DOM / 大对象泄漏
---
## 作用域 & 作用域链

作用域类型
- 全局
- 函数
- 块级（let / const）
---
作用域链查找
当前 → 外层 → 全局

📌 只向外找，不向内找
---
## 原型 & 原型链（画图级）

四大核心关系

实例.__proto__ === 构造函数.prototype
构造函数.prototype.constructor === 构造函数
原型对象.__proto__ === Object.prototype
Object.prototype.__proto__ === null
---
原型链查找顺序

实例 → prototype → Object.prototype → null

工程铁律
- 方法放 prototype
- 私有变量用闭包 / this
- prototype 不要写箭头函数
---
## 继承（只背这 1 种）

组合继承（ES5）

```js
function Parent() {
```
  this.a = 1
}

Parent.prototype.say = function () {}

```js
function Child() {
```
  Parent.call(this)
}

Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
---
ES6 extends 本质

```js
class Child extends Parent {}
```
// ≈ Parent.call(this) + 原型链连接
---
## new 做了什么（必背）

```js
function newFn(Fn) {
  const obj = {}
```
  obj.__proto__ = Fn.prototype
  Fn.call(obj)
```js
  return obj
```
}
七、经典必挂点（面试官最爱）

❌ 错误认知
- 闭包 = 嵌套函数 ❌
- prototype 是作用域 ❌
- this 指向定义位置 ❌
---
✅ 正确认知
- 闭包是“作用域没死”
- prototype 是“属性查找链”
- this 是“运行时绑定”
---
八、三句封神总结（背下来）

JS 的三大机制：
- 作用域决定“你能用谁”
- this 决定“你是谁”
- 原型决定“你从哪来”
---
九、面试现场万能结尾话术（直接用）

“这个问题核心不是语法，而是 JS 的运行机制：this 的绑定规则、作用域链的查找顺序，以及原型链的属性查找逻辑。”

