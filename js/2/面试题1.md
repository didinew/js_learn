JS 压力面试满分模拟 · 核心题 + 秒杀答案
---
Q1 执行上下文三部分

题目： JS 执行上下文包含哪三部分？

满分答案：

执行上下文包括 变量环境（var/let/const/function）、作用域链（当前→外层→全局）、this 绑定（普通函数调用时确定，箭头函数继承外层）。

面试官连环追问：
	1.	普通函数的 this 什么时候绑定？
- 秒杀回答： 调用时决定，取决于调用方式（隐式、显式、new、默认）。
	2.	箭头函数的 this 怎么确定？
- 秒杀回答： 定义时继承外层作用域的 this，一旦确定不可改变。
	3.	作用域链和闭包有什么关系？
- 秒杀回答： 闭包就是函数 + 其访问的外层作用域，作用域链保证变量可达。
---
Q2 闭包陷阱

```js
function counter() {
  let count = 0
  return function() { return ++count }
```
}
```js
const c1 = counter()
const c2 = counter()
console.log(c1()) // ?
console.log(c2()) // ?

```
满分答案：

c1(): 1
c2(): 1

每次调用 counter 都创建独立闭包，c1 和 c2 的 count 互不影响。

追问：
	1.	闭包为什么还能访问 count？
- 因为闭包延长了 count 的生命周期，变量仍然可达。
	2.	如果 count 很大，会有什么风险？
- 可能占用内存，需合理释放引用，避免泄漏。
	3.	闭包和原型方法冲突怎么办？
- 原型方法不能访问构造函数私有变量，闭包可以，用法区分。
---
Q3 原型链查找
```js
function A() {}
```
A.prototype.x = 100
```js
const a = new A()
```
a.x = 200
```js
console.log(a.x, A.prototype.x)
```
满分答案：

200 100

实例属性覆盖 prototype 属性，查找顺序：实例 → 原型 → Object.prototype → null。

追问：
	1.	a.hasOwnProperty(‘x’) 返回什么？
- true，因为实例自己有 x。
	2.	如果删除 a.x 再访问 a.x？
- 输出 100，从原型链查找。
	3.	构造函数 prototype 上的方法能访问实例私有变量吗？
- 不能，只能访问实例属性通过 this 访问。
---
Q4 继承 + this

```js
function Parent() { this.a = 1 }
```
Parent.prototype.say = function() { return this.a }
```js
function Child() { Parent.call(this); this.b=2 }
```
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
```js
const c = new Child()
console.log(c.say())
```
满分答案：
1

Child 构造函数调用 Parent.call(this) 继承实例属性，原型链继承方法。

追问：
	1.	Child.prototype.constructor 为什么要重置？
- 否则 constructor 指向 Parent。
	2.	直接 Child.prototype = new Parent() 有问题吗？
- 会执行 Parent 构造函数，创建多余实例属性，不推荐。
	3.	say 内的 this 指向谁？
- c 对象实例。
---
Q5 Event Loop + Promise / async

```js
console.log('start')
```
setTimeout(()=>console.log('timeout'),0)
Promise.resolve().then(()=>console.log('promise'))
```js
console.log('end')

```
满分答案：
start
end
promise
timeout

同步执行 start/end → 微任务 promise → 宏任务 timeout

追问：
	1.	微任务和宏任务区别？
- 微任务（Promise.then, queueMicrotask）在当前宏任务执行完立即执行；宏任务（setTimeout, I/O）在下一轮事件循环。
	2.	async/await 属于哪种任务？
- await 后面的代码作为微任务。
	3.	Promise.then 链式调用的原理？
- then 返回新的 Promise，并在状态改变时执行回调。
---
Q6 闭包 + 内存泄漏
```js
function foo() {
  let a = {}
  return function() { return a }
```
}
```js
const f = foo()
```
f = null

满分答案：

当 f 被置为 null，闭包引用解除，对象 a 变为不可达，GC 可以回收。

追问：
	1.	为什么闭包会阻止 GC？
- 因为闭包仍引用外层变量，使其可达。
	2.	定时器引用闭包会怎样？
- 会造成内存泄漏，需清除引用/定时器。
	3.	WeakMap 可以解决闭包泄漏吗？
- 可以，WeakMap 弱引用，不阻止 GC。
---
Q7 高阶函数 / 函数式

reduce 实现 map

```js
const arr = [1,2,3]
const mapped = arr.reduce((acc, cur) => [...acc, cur*2], [])
console.log(mapped) // [2,4,6]

```
柯里化 add(a)(b)(c)

```js
const add = a => b => c => a+b+c
console.log(add(1)(2)(3)) // 6
```
防抖 debounce

```js
function debounce(fn, delay, immediate=false){
  let timer
  return function(...args){
    if(immediate && !timer){ fn.apply(this,args) }
```
    clearTimeout(timer)
    timer = setTimeout(()=>{ if(!immediate) fn.apply(this,args) }, delay)
  }
}

追问：
	1.	防抖和节流区别？
- 防抖：最后一次触发，延迟执行。
- 节流：固定间隔触发。
	2.	debounce 为什么要 clearTimeout？
- 避免重复执行，延长间隔。
	3.	高阶函数有什么优势？
- 可复用、组合能力强。
	