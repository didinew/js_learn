# 一句话总规则（先背）

this 的指向，取决于“函数是如何被调用的”，而不是写在哪里
---
## this 的 6 大指向规则（从高到低）

1️⃣ new 调用（优先级最高）
```js
function Person(name) {
```
  this.name = name
}
```js
const p = new Person('Tom')
```
✅ this → 新创建的实例对象

发生了什么？
	1.	创建空对象
	2.	this 指向该对象
	3.	执行函数
	4.	返回对象
---
2️⃣ 显式绑定：call / apply / bind

```js
function fn() {
  console.log(this.name)
```
}
```js
const obj = { name: 'Alice' }

```
fn.call(obj)
fn.apply(obj)
fn.bind(obj)()
✅ this → 传入的第一个参数

⚠️ 面试追问：
- bind 不会立即执行
- bind 返回的是 新函数
- bind 不能被 call/apply 再改 this
---
3️⃣ 隐式绑定（对象调用）

```js
const obj = {
```
  name: 'Bob',
  say() {
```js
    console.log(this.name)
```
  }
}
obj.say()
✅ this → 调用该方法的对象

💣 隐式绑定丢失（必考）
```js
const say = obj.say
```
say() // ❌ this → window / undefined

原因：调用者丢了
---
4️⃣ 默认绑定（独立函数调用）
```js
function fn() {
  console.log(this)
```
}
fn()
- 非严格模式：this → window
- 严格模式：this → undefined

'use strict'
fn() // undefined
---
5️⃣ 箭头函数（不绑定 this）

```js
const obj = {
```
  name: 'Tom',
  say: () => {
```js
    console.log(this.name)
```
  }
}
obj.say() // ❌ undefined
✅ 箭头函数：
- 没有自己的 this
- this 取决于定义时的外层作用域
- call / apply / bind 无效

正确用法
```js
const obj = {
```
  name: 'Tom',
  say() {
    setTimeout(() => {
```js
      console.log(this.name)
```
    })
  }
}
---
6️⃣ 事件中的 this（DOM 高频）

button.onclick = function () {
```js
  console.log(this)
```
}

✅ this → 触发事件的 DOM 元素

button.onclick = () => {
```js
  console.log(this)
```
}
❌ this → 外层 this（通常是 window）


## this 优先级口诀（必背）

new > bind > call/apply > 对象调用 > 默认绑定

箭头函数：直接无视这套规则
---
## 面试必杀陷阱题 🔥

题 1：this 指向？

```js
const obj = {
```
  name: 'A',
  foo() {
```js
    console.log(this.name)
```
  }
}

```js
const bar = obj.foo
```
bar()
❌ 输出：undefined

✔️ 原因：隐式绑定丢失
---
题 2：定时器中的 this

```js
const obj = {
```
  name: 'A',
  foo() {
    setTimeout(function () {
```js
      console.log(this.name)
```
    })
  }
}
obj.foo()
❌ undefined

✔️ 改法：

setTimeout(() => {
```js
  console.log(this.name)
```
})
---
题 3：new + bind

```js
function Foo() {
```
  this.a = 1
}
```js
const bar = Foo.bind({ a: 2 })
const obj = new bar()
console.log(obj.a)

```
✅ 输出：1

原因：new 的优先级 > bind
---
## 实战总结（怎么用不翻车）

✅ 方法里：普通函数

✅ 回调 / 定时器：箭头函数

❌ 不要把对象方法直接解构使用

```js
const { foo } = obj // 危险
```
✅ React / Vue 中：
- Vue methods：普通函数
- setup / hooks：注意箭头函数 this 为 undefined
---
## 一句话面试满分回答模板 🎯

this 是 JavaScript 在函数执行时动态绑定的，
由调用方式决定。
new 调用优先级最高，其次是 bind、call/apply，
再是对象调用，最后是默认绑定。
箭头函数不绑定 this，而是继承定义时的作用域 this。

