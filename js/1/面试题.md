
1️⃣ ES Module 与 CommonJS 的区别

标准答案：
- 语法：
- CommonJS（CJS）：使用 require() 导入，module.exports 导出。
- ES Module（ESM）：使用 import/export 语法。
- 加载机制：
- CJS 是 同步加载，在运行时加载，适合 Node.js。
- ESM 是 静态编译，编译时就确定依赖关系，浏览器和打包工具友好。
- 作用域：
- ESM 默认严格模式，有自己的作用域。
- CJS 文件是模块化的，但导入的是 值的引用的拷贝。
- 兼容性：
- Node.js 早期仅支持 CJS，现代支持 ESM，但需要 "type": "module"。
- 浏览器原生支持 ESM，可以直接 <script type="module">。

面试官追问 & 高分回答：
	1.	追问：为什么 ESM 可以做 Tree Shaking？
- 因为 import/export 是静态解析的，打包工具在编译时就知道哪些代码未使用，可以安全删除。
	2.	追问：CJS 导出对象是引用吗？
- 是的，module.exports 导出的对象在 require 时会返回同一引用，修改导出对象会影响所有引用它的模块。

加分话术：

ESM 有利于前端现代化优化（Tree Shaking、按需加载），CJS 更适合传统 Node.js 服务端开发。了解两者互转很重要（esm包 / require()动态导入）。


2️⃣ 如何设计可维护、可复用的项目目录结构

标准答案：
- 原则：按功能/模块拆分，关注点分离，保证团队协作和可扩展性。
- 典型结构（Vue / React 项目示例）：

| src/ | ├─ assets/        # 图片、字体、样式 | ├─ components/    # 可复用组件 |
| --- | --- | --- |
| ├─ views/         # 页面组件 | ├─ store/         # 状态管理（Vuex/Pinia/Redux） | ├─ router/        # 路由配置 |
| ├─ utils/         # 工具函数 | ├─ services/      # 接口调用 / API 封装 | ├─ hooks/         # 自定义 hooks / composables |
 └─ App.vue / main.js
- 可维护技巧：
- 每个模块或功能尽量独立（独立组件 + 独立状态）。
- 公共组件、工具函数统一管理。
- 使用命名约定和文档提高可读性。
- 可复用技巧：
- 避免硬编码、可配置化。
- 使用组件库或工具库（Lodash、Axios 封装）。
- hooks / composable 抽象逻辑。

追问：
- 面试官：如果项目很大怎么办？
- 可以做 按功能分包（feature-based），或者多层级 modules/featureX/{components,services}。
---
3️⃣ Git Flow 如何保证多人协作不冲突

标准答案：
- Git Flow 核心分支：
- main/master：生产分支
- develop：开发集成分支
- feature/*：新功能分支
- release/*：预发布分支
- hotfix/*：线上修复分支
- 保证多人协作：
	1.	每个人在 feature 分支开发，避免直接修改 develop。
	2.	完成后先 pull 最新 develop，解决冲突再 merge。
	3.	merge 采用 PR + Code Review 流程，保证质量。
	4.	release 分支集中打包、测试，减少主分支冲突。
	5.	hotfix 分支快速修复生产问题，不影响 ongoing feature。

追问：
- 面试官：merge vs rebase 用哪种？
- feature 分支可以 rebase 保持提交记录清晰；合并到 develop 或 main 推荐 merge 保留历史。

加分话术：

Git Flow 不仅是流程，更是 团队协作纪律，可以结合 CI/CD 做自动测试和自动部署，提高协作效率。
---
4️⃣ 如何通过模块化 + 构建工具优化项目性能

标准答案：
	1.	模块化：
- 使用 ESM / CJS / UMD 按功能拆分模块。
- 按需加载（code splitting / lazy loading）。
- 避免全局依赖，提高缓存命中率。
	2.	构建工具优化：
- 打包优化：
- Tree Shaking 删除未使用代码
- 压缩（Terser、esbuild）
- 分包（chunking）
- 资源优化：
- 图片、字体压缩
- CSS 提取、按需加载
- 静态资源缓存、长缓存策略
- 开发优化：
- HMR 提高开发效率
- Source Map 分离，减小生产包大小

追问：
- 面试官：模块化如何影响首屏加载？
- 按需加载模块可以降低首屏 JS 体积，提升首屏渲染速度。

加分话术：

结合 Webpack / Vite / Rollup + ESM，可以做到 高性能、可维护、易复用 的前端架构。