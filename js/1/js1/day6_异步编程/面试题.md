## async/await 为什么看起来像同步，但本质还是异步？

一句话结论（先给你标准答案）

async / await 只是“语法糖”，让异步代码“写起来像同步”，但执行机制仍然是基于 Promise + 事件循环的异步流程。

“像同步” ≠ “变成同步”

# 为什么「看起来像同步」？

先看代码：
async function fn() {

```js
console.log(1);
const res = await fetchData();
console.log(res);
console.log(2);
```

}

表面执行顺序像这样：
1
res
2

- 就像普通同步代码一行一行往下走。

本质原因只有一个：

```js
await 会“暂停当前 async 函数的执行”，但不会阻塞 JS 主线程
```

---

## await 到底干了什么？（核心）

关键点：await 只做了两件事 1. 把后面的代码“切开” 2. 注册到 Promise.then() 里

等价代码👇（非常重要）：
async function fn() {

```js
console.log(1)

fetchData().then(res => {
console.log(res)
console.log(2)
```

})
}
也就是说：

```js
await xxx;
```

≈
Promise.resolve(xxx).then(继续执行后面的代码)

---

## 那为什么主线程没被阻塞？

因为 JS 真正同步阻塞是这样的：
while(true) {} // 主线程卡死
而 await 并不是这样。

```js
await 的行为是：
```

- ❌ 不阻塞主线程
- ✅ 只“暂停当前 async 函数”
- ✅ 把后续代码放进 微任务队列（microtask）

---

## 事件循环角度解释（面试加分点）

看这段代码：

```js
console.log("start");

async function test() {

console.log("a");
await Promise.resolve();
console.log("b");

}

test()

console.log("end");
```

执行顺序是：

start
a
end
b

为什么？

执行流程：1. 同步执行

- start
- a 2. await Promise.resolve()
- 后面的 console.log('b') 👉 进入微任务队列 3. 同步代码继续执行
- end 4. 当前宏任务结束 5. 执行微任务
- b
- await 后面的代码，一定是异步执行的

---

## 为什么说 async/await 是“语法糖”？

因为它 没有改变底层模型：
对比
本质
async/await
Promise + then

```js
await
```

微任务
看起来同步
代码结构
实际执行
事件循环

- JS 从来没有变成多线程同步执行

七、面试官最想听的一句话（背下来）

async/await 并没有让 JS 变成同步，它只是把 Promise.then 的链式写法，变成了更符合人类直觉的顺序代码，本质依然依赖事件循环和微任务。
