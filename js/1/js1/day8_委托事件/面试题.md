---
# 什么是事件委托（一句话版）

事件委托：

不把事件绑定在每个子元素上，而是统一绑定在它们的父元素上，利用事件冒泡，在父元素中处理子元素的事件。

ul.addEventListener('click', (e) => {
```js
  if (e.target.tagName === 'LI') {
    console.log(e.target.innerText)
```
  }
})
- 点的是 li，监听的是 ul
---
## 事件委托的原理（面试重点）

1️⃣ 浏览器事件流

事件经历三个阶段：
捕获阶段 → 目标阶段 → 冒泡阶段（默认）

事件委托 利用的是「冒泡阶段」：
li → ul → body → document

当你点击 li：
- 事件会一直冒泡到 ul
- ul 上的监听器就能“接住”这个事件
---
## 为什么事件委托性能更好？（核心）

❌ 不用事件委托（低性能）
listItems.forEach(li => {
  li.addEventListener('click', handler)
})

问题：
- 每个 li 都有一个监听函数
- 元素越多，监听器越多
- 占用内存 + 初始化慢
---
✅ 使用事件委托（高性能）
ul.addEventListener('click', handler)

优势总结👇

🚀 性能更好的 3 个本质原因

① 减少事件监听器数量
- 1000 个 li → 1 个监听器
- 节省内存

② 减少 DOM 操作成本
- 不需要频繁 add/removeEventListener
- DOM 操作是昂贵的

③ 动态元素天然支持

ul.innerHTML += '<li>新项</li>'
- 新增的 li 不用重新绑定事件
---
## 典型应用场景（面试加分）

✅ 列表点击
ul > li

✅ 表格操作
table > tr > td

✅ 按钮组 / 菜单 / Tabs

✅ React / Vue 内部事件系统

React 的事件本质就是 事件委托到 document
---
## 事件委托的注意点（必考坑）

⚠️ 1. 不是所有事件都能委托

❌ 不冒泡的事件 不能委托：
- blur
- focus
- mouseenter
- mouseleave
- 对应可替代：
- focusin / focusout
- mouseover / mouseout
---
⚠️ 2. 需要精准判断 target

ul.addEventListener('click', e => {
```js
  const li = e.target.closest('li')
  if (!li) return
```
})

否则：
- 点到 span / icon 会误判
---
## 面试官追问（直接背）

Q1：事件委托为什么比直接绑定快？

因为减少了事件监听器数量，降低内存占用，并且避免频繁 DOM 事件绑定操作。
---
Q2：React 事件是怎么做的？

React 把事件统一委托到 document，通过合成事件系统分发，提高性能和一致性。

Q3：事件委托一定更好吗？

不一定。
对于少量、固定、不冒泡事件，直接绑定更清晰。
---
七、一句话终极总结（面试王炸）

事件委托是利用事件冒泡，把多个子元素的事件统一交给父元素处理，从而减少监听器数量、降低内存消耗、提升性能，并天然支持动态元素。
