| ❌ 题 1：为什么频繁操作 DOM 会导致页面卡顿？ | ✅ 标准满分答案 |
| --- | --- |
| 因为 每一次 DOM 读写都可能触发浏览器的渲染流程，包括 | Reflow（回流 / 重排）和 Repaint（重绘）。 |
| 浏览器渲染流程是： | JS → Style → Layout → Paint → Composite |
频繁 DOM 操作会不断打断这条流水线，导致：
- 多次计算布局（Layout）
- 多次绘制像素（Paint）
- 主线程被占用，造成卡顿

哪些操作一定会触发 Reflow？

✅ 必答关键词
- 修改几何属性：width / height / padding / margin / top / left
- DOM 结构变化：appendChild / removeChild
- 读取布局信息：
offsetHeight / offsetWidth / getComputedStyle / getBoundingClientRect

⚠️ 读也会触发 Reflow（如果布局脏了）

为什么 读取 DOM 属性 也可能很慢？

✅ 答案：

浏览器为了返回最新值，必须先强制执行一次 Layout（强制同步回流）

| ❌ 题 2：为什么「批量修改 DOM」比「循环逐条修改」性能好？ | for (let i = 0; i < 1000; i++) { |
| --- | --- |
| el.style.width = i + 'px' | } |
| 为什么这段代码性能差？ | ✅ 标准答案 |
问题不在循环，而在于：
- 每一次 style 修改都是一次潜在的布局变更
- 浏览器可能在每次循环中执行 Layout

这会产生 Layout Thrashing（布局抖动）
---
✅ 正确优化方式（必须说出 2 种）

方式 1：合并 DOM 操作
el.style.cssText = 'width:100px;height:100px'
方式 2：使用 class 替代 style
el.classList.add('big')
方式 3：脱离文档流操作
```js
const frag = document.createDocumentFragment()

```
为什么 classList.add 比直接改 style 更好？

✅ 标准答法：
- classList 只触发一次样式计算
- style 是 逐条声明式修改
- CSS 可以被浏览器统一优化、合并计算

❌ 题 3：为什么 transform / opacity 动画比 top / left 流畅？
✅ 标准答案（必须完整）

因为：
- top / left 会触发 Layout + Paint
- transform / opacity 只触发 Composite
- 不参与文档流，不影响其他元素布局

浏览器可以把它们放到 合成线程（Compositor Thread），避免阻塞主线程
---
🔥 追问（面试官最爱）

transform 一定不会触发 Reflow 吗？
✅ 正确答案：

是的，不会触发 Reflow，
但会触发 Composite

⚠️ 前提：元素没有影响布局（如未参与 flow）

🧠 一句话速记（面试救命版）
- ❌ DOM 慢 ❌
- ✅ 慢的是「浏览器渲染流程被反复打断」
- Layout 最贵，其次 Paint，Composite 最便宜
- 读写 DOM 混用 = 必卡
- 动画只用 transform / opacity

