---
| 1️⃣ childNodes 和 children 的区别 | 特性 | childNodes | children |
| --- | --- | --- | --- |
| 返回类型 | NodeList（包含元素、文本节点、注释节点等） | HTMLCollection（只包含元素节点 <tag>） | 节点类型 |
| 元素节点 + 文本节点 + 注释节点 | 只包含元素节点 | 实时性 | 实时更新（live） |
| 实时更新（live） | 用途 | 需要遍历所有节点，包括文本/换行符 | 只想获取 DOM 元素节点，避免空文本干扰 |
💡 小结：
- childNodes 更全面，但可能包含换行符或空格文本节点，需要判断 nodeType === 1 才是元素。
- children 更干净，直接获取元素节点，开发中更常用。

<div id="box">
| <p>Hi</p> | <p>Bye</p> |
| --- | --- |
| <!-- 注释 --> | </div> |
| const box = document.getElementById('box'); | console.log(box.childNodes); // NodeList(5) => 文本节点 + p + 文本 + p + 文本 |
```js
console.log(box.children);   // HTMLCollection(2) => 只含两个 <p>
```
---
2️⃣ nextSibling 和 nextElementSibling 的区别

| 特性 | nextSibling | nextElementSibling | 返回类型 |
| --- | --- | --- | --- |
| Node | Element | 节点范围 | 下一个节点，不管类型（元素、文本、注释都算） |
| 下一个 元素节点 | 常见问题 | 换行或空格会被算作文本节点 | 只会跳过文本/注释节点，直接拿到元素节点 |
| <div id="box"> | <p>1</p> | <p>2</p> | </div> |
```js
const p1 = document.querySelector('p');
console.log(p1.nextSibling);        // 文本节点（换行符）
console.log(p1.nextElementSibling); // <p>2</p>

```
💡 小结：
- 如果只关心元素节点，推荐用 nextElementSibling。
- nextSibling 更底层，适合操作所有节点类型。
---
3️⃣ 为什么批量操作比循环插入单个元素性能更好？

原因主要涉及 DOM 重排（reflow）和重绘（repaint） 的机制：
	1.	DOM 操作是昂贵的
- 每次 appendChild / insertBefore 都可能触发 重排（重新计算布局）和 重绘（重新渲染页面）。
- 浏览器会根据最新的 DOM 重新计算几何位置、样式、绘制。
	2.	循环插入会多次触发重排

```js
const ul = document.querySelector('ul');
```
items.forEach(text => {
```js
    const li = document.createElement('li');
```
    li.textContent = text;
    ul.appendChild(li); // 每次都会触发一次重排
});


	3.	批量操作只触发一次重排
- 用 DocumentFragment 批量操作：
```js
const ul = document.querySelector('ul');
const frag = document.createDocumentFragment();

```
items.forEach(text => {
```js
    const li = document.createElement('li');
```
    li.textContent = text;
    frag.appendChild(li); // 在内存中操作
});

ul.appendChild(frag); // 一次性插入，重排只触发一次

✅ 性能提升明显，尤其是大数据量插入场景。

💡 总结原理：
- 单次操作触发一次重排 → 高效
- 多次操作逐次触发重排 → 性能低
- 内存中批量构建 DOM → 一次插入 → 最优

