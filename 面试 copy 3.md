👉 state 和 props 有什么区别？什么时候用 state，什么时候用 props？
state 是组件内部的可变状态，用来描述组件自身的 UI 状态变化；
props 是父组件传给子组件的只读数据，用于组件之间的数据通信。

使用原则：
	•	组件自己控制、自己变化的状态 → state
	•	需要从父组件传入、由父组件控制的数据 → props
	•	当一个状态被多个组件使用时，应状态提升，放到最近的公共父组件，通过 props 下发

设计思想：
	•	props 保证了单向数据流
	•	让组件数据来源清晰、行为可预测、方便调试和复用

state 管理组件自身的可变状态，props 用于父子组件通信；
谁拥有状态，谁就负责修改它，保证单向数据流和可预测性。


👉 key 的作用是什么？为什么不推荐使用 index 作为 key？

key 的作用是帮助 diff 算法在新旧虚拟 DOM 之间建立稳定的节点映射关系，
用来判断哪些节点是复用、移动还是销毁重建。

为什么不推荐用 index？

① 列表增删会导致“身份错位”
组件实例被错误复用 → 状态错乱

② 会导致不必要的 DOM 更新

index 变化 ≠ 数据真的变化
但 diff 会认为「全部节点都变了」

👉 本该移动，却变成重建

③ index 不是“稳定标识”

key 的核心要求只有一个：稳定 + 唯一


列表内容固定、不会发生增删或重排，并且子组件没有内部状态时，index 是安全的。

key 决定的是节点的“身份”，不是位置。
用 index 会让 diff 把“移动”误判成“修改”。

👉 父组件更新，一定会导致子组件重新渲染吗？为什么？

	1.	默认行为（React / Vue）
	•	父组件重新渲染时，子组件会重新执行函数式组件 / render
	•	但是是否真正 更新 DOM，取决于 子组件 props 是否变化 或 内部优化
	2.	细节补充：优化情况
	•	React：
	•	React.memo 或 PureComponent → props 没变 → 子组件不重新渲染
	•	Vue 3：
	•	静态节点 + v-memo / 响应式追踪 → 未变化 → 不会触发真实 DOM 更新
	•	总结：函数执行可能会重新走，但 不一定会触发真实 DOM 更新
	3.	面试高分答法示例

父组件更新会导致子组件的 render 或 setup 被重新执行，但子组件是否真正更新视图取决于 props 是否变化或是否使用了 memo/缓存优化。
这样既保证数据一致，又避免不必要的渲染。

追问 1：父组件更新，子组件内部 state 会丢失吗？
	•	React：
	•	内部 state 不会丢失，只要子组件是 同一个组件实例。
	•	父组件更新会触发子组件重新渲染，但 React 会保留子组件的 useState 状态。
	•	例外情况：
	•	如果子组件的 key 发生变化，React 会销毁旧组件，重新创建新实例 → state 会丢失。

		•	Vue 3：
	•	组件的内部 data 或 ref/reactive 状态同样 不会因父组件重新渲染而丢失。
	•	只有当 组件被销毁重建（如 v-if 切换或 :key 改变）时，状态才会丢失。
	•	总结：React/Vue3 都是“组件实例不变 → state 保留；实例变 → state 丢失”。

⸻

追问 2：props 没变，用 memo 真的安全吗？
	•	React.memo：
	•	默认 浅比较 props (===)。
	•	如果子组件 props 没变（同一引用），memo 可以阻止重新渲染。
	•	风险点：
	•	props 是对象/数组/函数，每次父组件渲染可能都会生成新引用 → memo 无效。
	•	对象深层内容没变，但引用变了，也会触发渲染。
解决方案：
	•	使用 useMemo / useCallback 保证引用不变。
	•	对深层对象，可传自定义比较函数：



👉 在 React 中，为什么直接在函数体里写 API 请求不合适？应该怎么做？

React 函数组件每次渲染都会执行函数体，如果直接在函数体里写 API 请求：
	1.	每次渲染都会触发请求 → 容易重复请求
	2.	可能在组件卸载后还更新 state → 报错

正确做法：
	•	使用 useEffect（带依赖数组）管理副作用，只在特定条件下发起请求
	•	或用自定义 Hook 封装请求逻辑

	

