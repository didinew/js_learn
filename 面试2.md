一、WebSocket & 高频数据（必问 3 题）

1️⃣ WebSocket 数据这么频繁，怎么保证页面不卡？

标准回答：

我不会每条消息都直接触发状态更新，而是先做一层数据缓冲。
WebSocket 收到的数据会进入 buffer，通过 节流（例如 100ms）批量合并，再统一更新状态。
同时会对数据做 去重和 diff 判断，避免无效渲染，列表和图表场景会配合虚拟渲染。

⸻

2️⃣ WebSocket 断线、重连怎么处理？

标准回答：

建立心跳机制定期检测连接状态，断线后按 指数退避策略 重连。
重连成功后会重新订阅频道，并通过最后一条时间戳进行 增量数据补拉，避免数据丢失或重复。

⸻

3️⃣ 实时行情为什么用 WebSocket 而不是轮询？

标准回答：

行情数据对实时性要求高，轮询在高频场景下延迟大、无效请求多。
WebSocket 是长连接，服务端主动推送，延迟更低，也更节省网络资源，特别适合交易和体育实时系统。

⸻

二、Vue / React 原理（必问 3 题）

4️⃣ Vue3 和 Vue2 最大的不同你用到了哪些？

标准回答：

主要是 Composition API 和 Proxy 响应式。
Composition API 更适合复杂逻辑拆分和复用，Proxy 可以更精准地追踪依赖，减少不必要的更新，在高频数据场景下优势明显。

⸻

5️⃣ React 中如何避免不必要的 re-render？

标准回答：

常用手段包括 memo、useCallback、useMemo 控制引用稳定性。
对于列表和高频数据，会避免直接 setState，而是批量更新或拆分子组件，减少渲染范围。

⸻

6️⃣ computed 和 watch / useEffect 怎么选？

标准回答：

computed / useMemo 用于纯数据派生，有缓存；
watch / useEffect 用于副作用处理，比如请求、订阅、埋点。
高频数据场景下，尽量用 computed，避免 watch 触发过多逻辑。
三、性能优化（大厂非常看重）

7️⃣ 你做过哪些性能优化？举一个最有代表性的

标准回答：

在实时行情页面，WebSocket 数据量大且更新频繁。
我通过 数据分片 + 节流合并更新 + 虚拟列表，把原来每秒多次渲染，降低到固定频率批量更新，明显提升了页面流畅度。

⸻

8️⃣ 虚拟列表原理是什么？

标准回答：

只渲染可视区域内的元素，其余用占位高度撑开。
滚动时根据 scrollTop 动态计算起始索引，复用 DOM，避免一次性渲染大量节点。

⸻

四、工程化 & 架构（区分初中级）

9️⃣ 你是怎么做组件封装的？

标准回答：

会优先抽象 稳定不变的结构和行为，把变化点通过 props / slots / 配置暴露。
对复杂组件会拆分为展示层和逻辑层，保证可复用和可维护。

⸻

🔟 多端（H5 / App / 小程序）怎么保证一致性？

标准回答：

核心业务逻辑尽量下沉到公共层，UI 层根据端能力做适配。
状态层通过统一的数据结构和更新策略保证一致性，端差异集中处理，避免业务代码分散。

⸻

五、加分追问（如果面试官很感兴趣）

如果他继续追，你可以说👇

“在高频数据场景，我会优先控制更新频率和更新范围，而不是单纯追求实时。”

这句话 非常大厂。

先做一个 1 分钟自我介绍：
👉 重点说 你最近 2–3 年做的核心项目 + 技术侧重点，不要念简历。

最近 2–3 年主要负责一个 多国家运营活动系统，使用 Vue3 构建，支持多主题、多语言和多端适配。
项目里有 高并发和高频实时数据场景，比如活动状态、赔率和实时统计。
我用 Pinia 管理状态，TypeScript 做强类型约束，避免复杂业务下的数据错误。
对 WebSocket 推送的数据，没有直接驱动 UI，而是做了 分片缓存 + 防抖批量更新，结合虚拟列表和 ECharts，保证实时性的同时控制渲染成本。
整体目标是 在复杂业务下保证稳定性和可维护性。

🧑‍💼 面试官追问 1（高频必问）

你刚才提到 WebSocket 大批量数据分片处理，
具体是怎么设计的？为什么要这么做？

✅ 做得好的点
	•	业务先分类（不是裸数据）👉 很工程化
	•	buffer 缓冲 + 100ms 批量更新 👉 正确处理高频 WS
	•	键值去重 👉 避免无效渲染
	•	虚拟列表 + 可视区域更新 👉 性能意识强
	•	requestAnimationFrame 控制渲染 👉 加分点



🧑‍💼 面试官：

如果 WebSocket 数据量突然暴涨，比如盘口或行情在极端波动下 数据量变成现在的 10 倍，
你这套方案最可能先出问题的是哪一层？你会怎么优化？

在数据量暴涨时，最容易成为瓶颈的是 业务聚合和状态更新层，因为这里会放大渲染成本。
我的策略不是强行保证数据完整，而是 优先保证 UI 可用性。
对于中间态或被覆盖的数据，会在 buffer 层进行 主动丢弃或合并，只保留最新有效状态。
同时限制单帧更新的数据量，确保每一帧渲染时间可控，避免 UI 卡顿。


🧑‍💼 面试官：

那你怎么保证 丢数据不会影响业务正确性？
哪些数据能丢，哪些一定不能丢？

对于 WebSocket 高频数据，我会在 buffer 层做优先级区分：
	•	核心业务数据（如资金、交易订单） 保证完整处理，按先后顺序逐条更新
	•	非关键展示数据 可丢弃或合并，保证 UI 渲染流畅
	•	通过这种分层策略，既保证了业务正确性，也避免了高频更新对性能的冲击

同时在 buffer 层，我会做 顺序校验和增量更新，确保核心数据一致性不会受到丢弃策略影响。

⸻

好的，既然你处理了高频数据，那么在虚拟列表 + ECharts 图表结合的场景下，你是怎么保证渲染性能和流畅度的？
在虚拟列表和 ECharts 图表结合的场景下，我会优先保证可视区域的数据渲染，确保用户看到的内容实时、流畅。
后台 buffer 层会做 键值对比，只对变化的数据做增量更新，避免全量刷新。
对于图表动画，我会结合 requestAnimationFrame 批量更新，把多条更新整合到一帧内渲染，保证高频数据下 UI 流畅且不卡顿。
这样实现了 “数据层可控 + 渲染层高性能” 的设计。

⸻

🧑‍💼 面试官：

你刚提到 requestAnimationFrame 批量更新，那在高频 WebSocket 场景下，
如果图表更新超过 60fps，你会怎么优化保证动画不卡顿？

在高频 WebSocket 更新下，如果图表更新频率超过 60fps，我会通过 预加载 + 懒加载结合 控制渲染量：
	•	预加载：提前准备好图表数据或 DOM 结构，减少渲染阻塞
	•	懒加载 / 批量更新：通过 requestAnimationFrame 或节流，每帧只渲染当前可视区域和变化数据，未变化的节点保持不动
	•	同时，对图表数据做 增量更新 而不是全量刷新
这样可以保证 动画流畅、UI不卡顿，即使 WebSocket 数据量暴增也能稳定。


⸻

一、增量更新概念（大厂话术）

增量更新是指只对发生变化的数据进行更新渲染，而不是全量刷新。
在高频数据场景（例如实时 K 线、盘口、活动状态）下，全量渲染会造成 DOM 重排 / JS 阻塞，直接影响流畅度和性能。

二、增量更新应用步骤
	1.	数据对比
	•	接收到新数据 → 对比原始数据的键值
	•	只找出 真正变化的字段或条目
	2.	可视区域筛选
	•	对列表 / 图表，只更新 可视范围内的数据
	•	不在屏幕显示的元素先缓存，不触发 DOM 更新
	3.	批量更新 / requestAnimationFrame
	•	将变化的数据整合到一帧内渲染
	•	避免每条消息触发 UI 渲染 → 降低重排次数
	4.	核心业务优先级
	•	核心数据（资金、订单）保证顺序和完整性
	•	非核心数据可以丢弃或延迟更新，保证整体流畅

⸻

三、增量更新示例（面试表述）

以 K 线图为例：
	•	每次 WebSocket 推送只更新最新一条或几条 K 线数据，而不是重画整个图表
	•	对 ECharts 使用 setOption 的 notMerge + lazyUpdate 参数，只修改变化的数据
	•	配合虚拟列表，列表滚动时只渲染可视区域行
	•	requestAnimationFrame 批量处理，保证渲染帧 ≤ 60fps

⸻

四、面试官追问方向
	1.	如果数据量暴涨 10 倍，增量更新还有效吗？
	•	答：核心数据优先处理，非关键数据丢弃；结合 batch 渲染 + 节流
	2.	增量更新如何保证数据顺序和一致性？
	•	答：通过 buffer 层按时间戳排序，关键业务数据保证顺序更新；可视区域增量渲染不会影响整体数据完整性
	3.	增量更新和全量更新的性能差异？
	•	答：全量更新 DOM / 图表每次都触发重排重绘，CPU 和内存消耗高；增量更新只修改变化部分，显著降低渲染成本，提高流畅度

⸻

一、Web Worker 概念（大厂话术）

Web Worker 是浏览器提供的 多线程环境，运行在主线程之外，可以处理耗时计算而不阻塞 UI 渲染。
在高频数据场景下，尤其是 WebSocket 大量推送 + 图表/虚拟列表更新，主线程可能被 JS 计算阻塞，导致动画掉帧或滚动卡顿。

⸻

二、应用场景
	1.	高频 WebSocket 数据处理
	•	buffer 分片、键值去重、增量计算 → 放到 Worker 里处理
	•	主线程只负责可视区域渲染
	2.	图表增量计算
	•	K 线、趋势线、ECharts 数据聚合、计算技术指标
	•	Worker 计算完成后 postMessage 给主线程渲染
	3.	虚拟列表数据计算
	•	滚动时动态计算索引、过滤数据、排序 → Worker 处理
	•	避免主线程阻塞滚动流畅性

在高频实时数据场景下，为了保证 UI 流畅，我会把 耗时的数据计算逻辑放入 Web Worker：
	•	buffer 分片、键值对比、增量计算在 Worker 内完成
	•	处理完的数据通过 postMessage 发送到主线程，只渲染可视区域
	•	对图表计算技术指标或列表排序，也在 Worker 完成，主线程只做增量渲染
这样可以 降低主线程压力，保证动画帧率稳定，UI不卡顿

⸻

四、面试官追问方向
	1.	❓ Web Worker 和主线程通信会不会有性能问题？
	•	答：通信使用 postMessage，数据尽量结构化或可转移对象（Transferable）
	•	减少数据拷贝，尤其是大数组和对象
	2.	❓ 如果 Worker 也处理不过来怎么办？
	•	答：可 拆分多个 Worker，或批量处理
	•	非核心展示数据可延迟或丢弃
	3.	❓ Worker 能访问 DOM 吗？
	•	答：不能，Worker 只能做计算逻辑，DOM 渲染在主线程


⸻

一、JavaScript 基础与进阶

1️⃣ 闭包

问： 什么是闭包，有什么应用场景？
答：
	•	闭包是函数能访问定义在外部的变量，即便外部函数已返回
	•	应用： 缓存数据、模块化私有变量、计数器、事件回调保留状态

⸻

2️⃣ this 指向

问： 普通函数、箭头函数、类方法的 this 如何指向？
答：
	•	普通函数：调用者决定
	•	箭头函数：继承定义时作用域的 this
	•	类方法：按实例调用

⸻

3️⃣ 事件循环

问： JS 执行顺序及宏任务/微任务区别？
答：
	•	同步代码 → 微任务（Promise.then、queueMicrotask） → 宏任务（setTimeout、I/O）
	•	微任务优先执行，宏任务排队

⸻

4️⃣ 深浅拷贝

问： 如何实现深拷贝？
答：
	•	浅拷贝：Object.assign / {…obj}
	•	深拷贝：JSON.parse(JSON.stringify(obj))（有局限）或递归，或 structuredClone

⸻

5️⃣ 防抖 / 节流

问： 区别及场景
答：
	•	防抖：延迟执行，常用于输入框搜索
	•	节流：间隔执行，常用于滚动/resize

⸻

6️⃣ 异步处理

问： async/await vs Promise、并发控制
答：
	•	async/await：写法清晰，易处理顺序
	•	Promise.all：并行请求
	•	限制并发可用 promise pool

⸻

二、浏览器与性能优化

1️⃣ 渲染流程

答： HTML → DOM/CSSOM → Render Tree → Layout → Paint → Composite

⸻

2️⃣ 重排 vs 重绘

答：
	•	改尺寸/布局 → 重排
	•	改颜色/背景 → 重绘
	•	重排比重绘成本高

⸻

3️⃣ 前端性能优化

答：
	•	懒加载、骨架屏
	•	虚拟列表
	•	静态资源压缩/缓存/CDN
	•	Web Worker 分离计算

⸻

4️⃣ Web Worker

答：
	•	将耗时计算放到 Worker，主线程只渲染可视数据
	•	避免动画卡顿

⸻

5️⃣ 缓存策略

答： localStorage / sessionStorage / IndexedDB / Service Worker

⸻

三、Vue / React

1️⃣ Vue3 vs Vue2

答： Composition API + Proxy 响应式 + TS 支持 + 更轻量

⸻

2️⃣ React 渲染优化

答： memo/useMemo/useCallback，拆分子组件，减少全局 re-render

⸻

3️⃣ 虚拟 DOM

答： Diff 算法 + key + 增量更新

⸻

4️⃣ 状态管理

答：
	•	Pinia / Vuex / Redux
	•	多端同步方案：公共逻辑层 + 统一状态管理

⸻

5️⃣ 组件复用

答： props/slots/emit，高阶组件 / render props / composition

⸻

四、高频数据 & WebSocket

1️⃣ 实时数据渲染

答：
	•	buffer 缓冲区 + 防抖/节流（100ms） + 增量更新
	•	虚拟列表 + 可视区域渲染
	•	requestAnimationFrame 批量渲染

⸻

2️⃣ 数据丢弃策略

答：
	•	核心业务数据优先
	•	非核心数据可丢或延迟
	•	保证 UI 流畅性 + 业务正确性

⸻

3️⃣ 图表优化（ECharts / Highcharts）

答：
	•	增量更新代替全量刷新
	•	notMerge + lazyUpdate
	•	可视区域 + requestAnimationFrame

⸻

4️⃣ 高并发 WebSocket

答：
	•	心跳 + 重连机制
	•	增量补拉数据
	•	buffer 分片，按优先级处理

⸻

5️⃣ Web Worker

答：
	•	高频数据处理和图表计算放 Worker
	•	主线程只渲染可视区域
	•	避免主线程阻塞，保证 60fps 流畅
	•	postMessage 或 Transferable 优化数据传递

⸻

五、工程化 & 架构

1️⃣ 多端适配

答： 核心逻辑下沉到公共层，UI 按端能力适配，状态统一管理

⸻

2️⃣ 模块化组件化

答：
	•	可配置化组件
	•	抽象业务逻辑与展示逻辑
	•	提高复用与可维护性

⸻

3️⃣ 构建工具

答： Vite / Webpack，Tree-shaking, Code-splitting, 缓存策略

⸻

4️⃣ 安全

答： XSS / CSRF 防护，WebSocket 数据安全

⸻

🏆 前端组件封装面试标准答案

⸻

一、封装组件的目的

封装组件核心目的：复用、解耦、可维护、可配置
	•	将重复逻辑抽象成组件
	•	分离业务逻辑和展示
	•	提高开发效率，减少重复代码

⸻

二、封装思路（Vue3/React 通用）

1️⃣ 组件层次设计
	•	展示型组件（Dumb/Presentational）
	•	只负责 UI，props 接收数据和事件
	•	业务型组件（Smart/Container）
	•	负责业务逻辑、状态管理
	•	可调用子组件完成展示

2️⃣ 属性与事件设计
	•	Props：数据输入
	•	Slots / children：可扩展插槽
	•	Emit / Callback：事件输出
	•	默认值 + 类型检查（TS + PropTypes）

3️⃣ 可配置化设计
	•	通过 props/slots/config 控制样式、行为
	•	避免硬编码业务逻辑
	•	支持多主题、多语言切换

4️⃣ 状态管理
	•	局部状态：组件内部响应式 state
	•	全局状态：Pinia/Vuex/Redux
	•	与外部状态解耦，通过 props/emit 传递

⸻

三、性能优化
	1.	懒加载子组件
	•	Vue: defineAsyncComponent
	•	React: React.lazy + Suspense
	2.	避免无效渲染
	•	Vue: v-memo 或 watchEffect + computed
	•	React: memo / useMemo / useCallback
	3.	增量更新
	•	高频数据组件（列表/图表）只更新变化部分
	4.	虚拟列表
	•	对大数据列表，渲染可视区域
	•	避免 DOM 节点过多

⸻

四、多端适配（H5 / App / 小程序）
	•	核心业务逻辑封装在公共层
	•	UI 层按端能力适配
	•	状态统一管理，接口统一调用

⸻

五、封装组件示例（大厂口语表述）

以虚拟列表 + 实时数据表格为例：
	•	将列表组件拆成DataTable（展示）和DataTableContainer（逻辑）
	•	Props 接收数据、列配置、分页
	•	Emit 输出选中行、排序、过滤事件
	•	高频数据通过 buffer + 防抖 + requestAnimationFrame 批量渲染
	•	支持多端、多主题切换，业务逻辑和 UI 分离

⸻

1️⃣ 为什么 Vue 组件 data 必须是函数？

追问 1️⃣：根实例为什么可以直接是对象？
答：根实例只创建一次，没有多实例共享问题。

追问 2️⃣：如果组件 data 是对象，会发生什么？
答：多个实例共享同一对象，修改一个实例会污染其他实例数据。

追问 3️⃣：Vue 2 和 Vue 3 在响应式上有差别吗？
答：Vue 2 用 Object.defineProperty，不能监听新增属性；Vue 3 用 Proxy，自然支持新增/删除属性。

⸻

2️⃣ v-if 和 v-show 的区别？

追问 1️⃣：v-if 和 v-show 性能差别在哪？
答：v-if 切换成本高，初次渲染 DOM；v-show 初次渲染成本低，但切换仅改变 display。

追问 2️⃣：什么时候 v-if 更合适？
答：条件很少变或组件不常显示时，减少 DOM 常驻成本。

追问 3️⃣：什么时候 v-show 更合适？
答：频繁切换显示状态时，避免频繁销毁和创建 DOM。

⸻

3️⃣ 为什么渲染列表一定要写 key？

追问 1️⃣：key 的作用是什么？
答：帮助虚拟 DOM 精准匹配节点，提高 diff 性能，避免 DOM 状态错乱。

追问 2️⃣：为什么不能用 index？
答：列表增删或排序时，index 会导致节点复用错误，状态错乱。

追问 3️⃣：什么时候 index 是安全的？
答：列表只读、不增删、不重排时可以用 index。

⸻

4️⃣ Vue 响应式原理？

追问 1️⃣：Vue 2 为什么监听不到新增属性？
答：Object.defineProperty 只能劫持已有属性，新增属性未被代理。

追问 2️⃣：Vue 3 是如何解决的？
答：使用 Proxy，可以拦截 get/set，天然支持新增/删除属性。

追问 3️⃣：Proxy 对性能有影响吗？
答：性能损耗很小，且比 Vue 2 的大量 defineProperty 更高效。

⸻

5️⃣ computed 和 watch 的区别？

追问 1️⃣：computed 的缓存机制是什么？
答：依赖收集，只有依赖变化才重新计算。

追问 2️⃣：watch 的主要用途是什么？
答：监听数据变化做副作用操作，比如异步请求或复杂逻辑。

追问 3️⃣：computed 能做异步吗？
答：不推荐，computed 应该同步、有返回值；异步放 watch。

⸻

6️⃣ Vue 为什么是异步更新 DOM？

追问 1️⃣：异步更新有什么好处？
答：合并多次状态修改，减少 DOM 操作，提高性能。

追问 2️⃣：状态修改和 DOM 更新的关系？
答：状态修改是同步的，DOM 更新是异步批量处理。

追问 3️⃣：如何强制同步更新？
答：可以使用 await nextTick() 确保 DOM 已更新。

⸻

7️⃣ nextTick 是干什么的？

追问 1️⃣：nextTick 内部实现原理？
答：优先使用微任务（Promise.then），不支持时降级到宏任务。

追问 2️⃣：为什么有些场景 nextTick 不起作用？
答：如果 DOM 没有变化或未触发响应式，回调不会执行。

追问 3️⃣：模板里需要 nextTick 吗？
答：模板自动响应更新，不需要；JS 里操作 DOM 或获取更新后的尺寸时才需要。

⸻

8️⃣ 生命周期有哪些？常用哪些？

追问 1️⃣：setup 和 mounted 区别？
答：setup 在组件实例创建前执行，无法访问 DOM；mounted DOM 已挂载，可操作节点。

追问 2️⃣：接口请求放哪里合适？
答：依赖 DOM → mounted；不依赖 DOM → setup/created。

追问 3️⃣：unmounted 常用来做什么？
答：清理定时器、取消订阅、解绑事件。

⸻

9️⃣ 父子组件通信方式？

追问 1️⃣：props / emit 的优势？
答：单向数据流、可追踪、易维护。

追问 2️⃣：provide / inject 缺点？
答：隐式依赖，调试困难，不适合高频数据。

追问 3️⃣：什么时候用 ref 父组件获取子组件方法？
答：操作第三方组件、表单聚焦、获取 DOM 尺寸，不用于业务状态。

⸻

🔟 v-model 本质？

追问 1️⃣：Vue 3 为什么改成 modelValue + update:modelValue？
答：支持多 v-model，避免 value / input 命名冲突。

追问 2️⃣：v-model 可以自定义事件名吗？
答：可以，通过 v-model:propName 指定。

追问 3️⃣：模板里需要 .value 吗？
答：模板自动解包 ref，JS 中必须显式 .value。

⸻

1️⃣1️⃣ ref 为什么要 .value？

追问 1️⃣：解构 ref 会丢响应式吗？
答：会，因为解构后是普通变量，失去 Proxy 代理。

追问 2️⃣：reactive 解构也会丢响应式吗？
答：会，解构对象会失去代理引用。

追问 3️⃣：如何保持响应式？
答：使用 toRefs() 或直接操作原对象。

⸻

1️⃣2️⃣ Composition API 优势？

追问 1️⃣：为什么 mixin 不推荐？
答：命名冲突，来源不清晰，难维护。

追问 2️⃣：逻辑复用用什么替代？
答：组合函数（useXxx）。

追问 3️⃣：Composition API 对 TS 有优势吗？
答：更友好，类型自动推导，更安全。

⸻

1️⃣3️⃣ Vue 性能优化？

追问 1️⃣：v-for + v-if 可以一起用吗？
答：不推荐，v-for 优先级高，v-if 每次循环都会判断。

追问 2️⃣：如何减少重渲染？
答：拆分组件、使用 computed 缓存、合理 key、按需渲染。

追问 3️⃣：动画和 DOM 更新优化？
答：用 transform / opacity 替代 top/left，利用 requestAnimationFrame。

⸻

1️⃣4️⃣ Vuex / Pinia 区别？

追问 1️⃣：Pinia 为什么不需要 mutation？
答：允许直接修改 state，简化心智负担，支持 TS。

追问 2️⃣：状态管理如何避免复杂依赖？
答：拆分 store，按模块管理，使用组合函数。

追问 3️⃣：Pinia 如何处理异步？
答：通过 actions 完成，支持 async/await。

⸻

1️⃣5️⃣ Vue 项目调试？

追问 1️⃣：线上 bug 如何定位？
答：sourcemap + 日志 + 复现最小场景。

追问 2️⃣：组件状态异常怎么办？
答：检查 props、emit、store、computed 依赖。

追问 3️⃣：Vue DevTools 有哪些必用功能？
答：组件树、状态监控、事件追踪、性能分析。

⸻

1️⃣6️⃣ Vue 权限控制？

追问 1️⃣：前端权限能保证安全吗？
答：不能，只能控制展示，真正安全靠后端。

追问 2️⃣：按钮级权限怎么做？
答：指令 + store 或 props 控制渲染。

追问 3️⃣：路由权限能做动态路由吗？
答：可以，登录后动态添加路由表。

⸻

1️⃣7️⃣ Vue 生命周期 & 异步更新总结

追问 1️⃣：为什么 created 访问不到 DOM？
答：组件还没挂载，DOM 未生成。

追问 2️⃣：mounted 能访问 DOM 为什么还要 nextTick？
答：状态更新后 DOM 未刷新，需要等待异步更新完成。

追问 3️⃣：更新多次状态，nextTick 有几次回调？
答：同一事件循环中多次更新只会触发一次回调，批量处理。

⸻

1️⃣8️⃣ 优缺点对比（Vue vs React）

追问 1️⃣：Vue 魔法多是什么意思？
答：自动响应、模板语法隐藏逻辑。

追问 2️⃣：React 更显式有什么好处？
答：可控性更强，逻辑更透明，复杂状态更安全。

追问 3️⃣：你选 Vue 还是 React？
答：根据团队和项目，Vue 上手快，React 可维护性高。

⸻

1️⃣9️⃣ Vue 组件复用策略？

追问 1️⃣：UI 和逻辑复用怎么区分？
答：UI → 组件，逻辑 → 组合函数。

追问 2️⃣：如何让逻辑复用可组合？
答：拆成小函数 useXxx，按需组合。

追问 3️⃣：逻辑复用能跨项目吗？
答：可以打包成 npm 包或 utils 库。

⸻

2️⃣0️⃣ 最大踩坑经历？

追问 1️⃣：具体是什么问题？
答：列出项目中真实遇到的 bug 或坑。

追问 2️⃣：原因分析？
答：解释为什么出现问题（状态丢失 / 异步 / 响应式问题）。

追问 3️⃣：如何解决？
答：解决方案 + 收获总结，体现思路。
